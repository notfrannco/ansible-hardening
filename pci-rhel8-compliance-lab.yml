---
# Red Hat Insights has recommended one or more actions for you, a system administrator, to review and if you
# deem appropriate, deploy on your systems running Red Hat software. Based on the analysis, we have automatically
# generated an Ansible Playbook for you. Please review and test the recommended actions and the Playbook as
# they may contain configuration changes, updates, reboots and/or other changes to your systems. Red Hat is not
# responsible for any adverse outcomes related to these recommendations or Playbooks.
#
# pci-rhel8-compliance-lab
# https://console.redhat.com/insights/remediations/2a2c6f97-141c-4842-8c25-61fad5b7b06d
# Generated by Red Hat Insights on Thu, 04 Nov 2021 16:26:48 GMT
# Created by jfranco-3

# Set Account Expiration Following Inactivity
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_account_disable_post_pw_expiration,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Account Expiration Following Inactivity
  hosts: 'tower.lab'
  become: true
  vars:
    var_account_disable_post_pw_expiration: '90'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelZ6ZG5jMU9FUXJhalZ3VGtGUmFrTlpaeTh2VTAxcGNt
      Rk5XVUV2TTFWdlJIbGplRFpKVW1oTmFsbDRjRU5rVEZWVmRFa0tkRFJNVlVWWFYwazFLMHhpVUhC
      VUsxVklOMWxGZVdNeE9FUk1ZamxWZGl0Q04zUjBUbkZITTJsUU1uTmxjMVZCUmxScWFHUkpSVGt6
      T0UwMmF6aEdXUXBRVUdwRVV5dFlaSEk1UldvMkwzcHlPU3M0VmtsekwweEhTbG8zTDB4U1NVc3pP
      WGg0UVZweGRsUmpUME5WUmxwUGMwNVVNRWMzWTBKS2NHcHdNazlJQ210SGVVWXpOalpETjFkTFQy
      dEVOQzlyVUVocE5tcHpTR0o1UW10TFJYQjJjM2RIUWpGS04yb3dla0ZXVDJab01rYzBZbVJwTDFW
      MFZreENOM2R3WjBFS2VXaGhVM1I1VkZSRmJFZFljVWhvTDNKSVFqQkZTekY0VlZsMmEyZG1jbVk1
      VjBsdVdUTndOWFIwV0N0bllqVTFTVmt2WW1KMFpXaHRNVVZNZDNRdkt3cE1LMjU0WW1SV1pFdEZh
      Rkl4YWxBeVlVMVZRalkyTkcwMGVGVlNiMDQ1V0dsS01VSm1NVkJ1VFZObVUzcFFSa0kxUjNWQ0ww
      VTNNblY1VlU1MlJHSmtDa2xQSzNCalJHZDZlakIxYVZWbWFDOXJka2MwU2s1cVpYazBTbUo2TjNC
      TFJrdHVjRE0xVVhWa2RrVnpXVUpYUWpnekwwYzRaRUZaTTFwWlRXdDVhVkFLTTNSU1IwOUNRWHBO
      VlUxdFRUaFVlbUpqVm1keFpHaDVWWEpRVFU4eWJtTnZSbUZPU1V4eFQxVnhUa1paT1dGck0ySkJT
      R2RuU0ZWT1lVOWFhRk5LU3dwTE9YSkdVa1ZKVGtKeE9XZHlaM3AzTVdRelUwZGtSVFV4Wm5OMU4y
      RkdMMmxVVm1OclZYVkNLMlYzVlhsV2IxYzBhVkZqYUhKMksyeERRV1V6U1daNkNrNTJlV2xvVmpG
      dVdtdDNhWE5KTldwVGJUQlFUVWsyVFhKck1FTk9PWFZuZUdkSVpXbzVja0pEUzFSdk1XcFVNMGh2
      UmtrNFpqRllaa3BCVjBwYU5YSUtaemhQTnpOVE0zaFZPVE5FUjFCNlpXWXZLMjR2Y21Oa1IxQmxh
      bW8zVUhNMU5pdDViVlJaU0doRmNHZFRjMjlqWTI5ek0ycGhXazkwT1c1WmJHMW5hQXBoVW1wd1J6
      VXpjSGM0U1QwS1BYZ3piR0VLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80954-1
    - CJIS-5.6.2.1.1
    - DISA-STIG-RHEL-08-020260
    - NIST-800-171-3.5.6
    - NIST-800-53-AC-2(3)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-4(e)
    - PCI-DSS-Req-8.1.4
    - account_disable_post_pw_expiration
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set Account Expiration Following Inactivity
      lineinfile:
        create: true
        dest: /etc/default/useradd
        regexp: ^INACTIVE
        line: INACTIVE={{ var_account_disable_post_pw_expiration }}
      when: '"shadow-utils" in ansible_facts.packages'


# Set Password Maximum Age
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_maximum_age_login_defs,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Password Maximum Age
  hosts: 'tower.lab'
  become: true
  vars:
    var_accounts_maximum_age_login_defs: '90'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelU0ZG5jMU9FUXJhalZ3VGtGUmFuVmhkeThyVFVaWFVt
      UjZTR3hhVkdKU1RuQnhXRk5CTkdGaFlXVlJOak0yVEZVdlNHOEtZVmd4UTA4M1FtbGtPVE41T0Vk
      UVpXbHJkMUZaU1dRME4xWm5OVlZCVkVWRlFVVXJMMFV5U2toNFZtaDFZV3hrWkhkVVZFdEtVbTlq
      TXpRdlJHbHJhd3AzZVRWWGRrcFNUVVpuU21SWlMxSnBXa1p4UmpoTVRsaEJlVzlsTmxaaU9XOWxa
      bTV6YmxwcGRrRXljMFp0TVhGT01GQnFXbE14TmtWV1VYQmpkMDkwQ2xJeVF6ZFZORVZFU0U1VU4z
      Uk9hbmhRTHpNNGRIbG5kV3BQT0hwUmF5OXJlQ3MwVkdkSVMycDBNR1o1Um13NVVHaG5iVzVWYUhO
      dE5uUlRkMEpoVWpZS01GZERkMEV2VlV4d2RTdExSVlZGTWpWSVpUaE5kV28xTUhaMksxRlRTSEJQ
      UWtaTldsTXdTM2xRYVZncmIwaDJTRmhwYml0WlVFTmxhamg1VDNWc2VRcGpORFo1YzI1V1NISm5N
      VFZPZUZGT1UxTnVaSFpsVEZOMFFXOW1SWGx1VERkVmNHZzVNMGhFTkhkelEydEtiRzFIWlRoelky
      VlplRWd3VWxsblNucHJDbXN4WTNCdk9WZHJOVVp1VTFWM1RFbHZla3BDVm1sNGMwVXdhME5WTVRC
      WU4zSnRZa3RLTDJ0TldXVnJURTR2UkZOak4zSmlSUzh5UlU4MVltUkxlR3NLV0V4VE1sbFRaVEox
      YzFjNUszaHBaRmQ2V21SMlZsZDVNVVJhVUZKVVowczFLMk14ZGtkNlNsa3pNWFZzWTIxRVJFUnJM
      M0E1ZFdOdlNVdGxWMnhXVlFvdlNWZGxOMmhJWnk5bWRISkdXVzRyYldOakwxbDRaMVJKU2twNlVW
      RTVabTFVVm5KSlFVcGhUQ3MzZDB0UmEweEtRVnBqTXpZNWFYUlBWM1phZEVKRkNqRXlMMGRuVkVs
      M2JVWm1UemhOYkhKYVRqZDZUVkpIWlRrMU5IVkhSa3htUTA1RFJVcDZXbkl3VjJaU1ZEWmtSM0pz
      Wm1rNVNFZFFLemhYTkU1UVZXTUtTbEJrTlU5NWFERmFXRzEwYzFOQlVtRk1WbnBIWmtaRlVVMWtj
      VUpYWlROR2NGWjVOMUJPYUhWVkt6TTNjVXhEV1d0UlV6aEJhSGR5UlVWT1VYSlliUXB3UkRaTlRr
      ZEpTbXN5VVQwS1BWWm1NbllLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80647-1
    - CJIS-5.6.2.1
    - DISA-STIG-RHEL-08-020200
    - NIST-800-171-3.5.6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(d)
    - NIST-800-53-IA-5(f)
    - PCI-DSS-Req-8.2.4
    - accounts_maximum_age_login_defs
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Set Password Maximum Age
      lineinfile:
        create: true
        dest: /etc/login.defs
        regexp: ^#?PASS_MAX_DAYS
        line: PASS_MAX_DAYS {{ var_accounts_maximum_age_login_defs }}
      when: '"shadow-utils" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Minimum Digit Characters
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_password_pam_dcredit,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_ubuntu
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Minimum Digit Characters
  hosts: 'tower.lab'
  become: true
  vars:
    var_password_pam_dcredit: '-1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelU0ZG5jMU9FUXJhalZ3VGtGUmFtVmpkeTh2WkdNdksy
      dE5lV1JDTUVzNU5WTnNWR0pMWkZCYU5XMUdPRGh5V21SMU1rWUtOa0p0UWxsVVpFdHlaM1ZKUTFZ
      elRqRXpjMHBxVnpKcVptUndVelF6VDBkRVdFUnFkVkI2T0daemJXdHpURVZtVGtneVZtTjBRazk1
      T1d4Q2VtRmplZ3BNWjFSRWFYSm5Ta0Z2ZWpKdGNHbHJLMVZZU0RsYWJWTktibmhoUTNNMlJGWlBk
      WGxVYVZkdmVIbzBVRWxsWWpaeEswTXZObW81TjJGc2FqUkRZVTh6Q2tkblRHdFZiV0pQYTFSelRq
      RTVPRXR0Um5NeFYzUjZZM0l6VTFGNWNXdFhOa3d5T0dWWkwzcHFhV1ZJU1RCREwxUkVXVk5YYnps
      ME1VcFlNazFpVEdjS09HcHFiR0ZwY21SaFJrcHdjVzAxUWtsbWQySXdWMU5ZV0dZdk5WTXlNbVF3
      UWxKcGJuVmFOMGc0TDBadmJYVnVkV05sY3poTVdsbHNXbTluWlhGNGFncDRRekZGTjBsd2NFWnRk
      VGxXZGpVMFpEZGhRM2hMU1dkRmNXVXlkRkZHWlhWeFQycExOSFV4VUVwMVdXSk1URVJRVVhBMmVV
      RjJNVVV5YzJoek9UTndDbGwxWW5waVFuZFZORlJWT0dKR1lqbExVMEZoYzJ4U2RtdEJibFIxT0VG
      TFpXMDFZV3BSYUZOUVRXWnBXRFoyUlVwRVoyTkZkREpuYkZkeEwyTkJlRTRLYjNKaWFEUkJSMUY2
      UzBsaFFuSmhhbkF6T1cxeGNVTlhSMWR4VUcxTE1HbGFkekJLY1hOb2VISlJVRkpLUTFaRGFGRlBO
      bWM0TnpGS1YzRlBTRGRYVXdwWlRIbGliek5uTDA1blVqVk5lVkp3UVZKQ2JtNXNUazFCUmpOa1Yy
      UktSV3BTYjNSbGRsSmFVM0kxZURsWVoyVlFjRFpvYzNGc2FGcGxjblJRVFdGMENuQnZaVmx2UVVR
      MGFIUmFSV3RaU2prelpUYzJhMmRWVG01WFEwMXFXSFI1ZEV4eWFtVlVUalpEUnpKVWMwUnVZVUZa
      VnpkTE9HYzNaRGRMWmpoYWNVOEtZblpvSzNKNVprbEJNWFZqUzBadlJsSXZUbFZJU2l0dFRUUjZj
      Mmh3TDFRM1pVMVRibTFUVW1SUFQwZGhXVnBrV2xNMlFtTXhVVGswWkVKR1JVRXlMd3BPTXlzelRq
      QnRTSGRRTkQwS1BWZ3hWa0lLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80653-9
    - DISA-STIG-RHEL-08-020130
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - PCI-DSS-Req-8.2.3
    - accounts_password_pam_dcredit
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM variable dcredit is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*dcredit
        line: dcredit = {{ var_password_pam_dcredit }}
      when: '"pam" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_password_pam_lcredit,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_ubuntu
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Minimum Lowercase Characters
  hosts: 'tower.lab'
  become: true
  vars:
    var_password_pam_lcredit: '-1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelpOZG5jMU9FUXJhalZ3VGtGUmFGUlZRUzh2VTFoVGEw
      ZHRNR1pJZUhONGNFTkpaa1JDUlV0RU5tazJiemxHVWtKM2QwZ0tMMDE0WlZoaGN5dGhNMnB0TUha
      cVprOVRkblE1ZUc1SE4zaFBXbkpTT1M5dE5GQmpZbkZXVlRCMVowOHlPVXd4VDJOU1duVnJaVk41
      WldsTU9FSm1OZ29yTDJneFFrOUtiRkUzYUVvelJtbG9VWFpYUjFkYVJsSjVVVTl1TlV4NFYycFFU
      a1Y2WTBsc1VsYzJSWFpqV2t4aVVrdFZVR1IxVkdrdk1WQTVRa05YQ2xVMWFsUm5TbU13VUd4dldV
      cHRhMjQzTjBJeFpFWkpVVVJHVW5Jck9GaDRZVkZVTURGSVZYQkNXR3hsVVVWUFZGbHZha3hITmpK
      Q1dFdEVkek5LYlZrS05DOHdhMWh0TTNocFZtZ3ZWbmhNWmtGaVQzaFBNMkpYVlRkMllXRXlWVkps
      ZG1sSFJGRjJXRzVwVkdndlZrSnFhR1p3T0V0NGQyMUZjVW93VjBWRlpRb3dUSGhUTTFCaU1scExh
      MjVuTVhOdU1teGtkbGx0VDBwbGEwSm1ibTAxUTNkb1RrUTNRVXBhTDI1cUszVmxTWHBTV1V3clRE
      aGhVSGxyUTFabGMwVlhDbmh2VFZGWk4wVkxiVzB5VDNkTFNtTm1SSEptTUVkTmRGQXJhMVpZYzBS
      UlZHRkpjR2RpUVRSVFVGSnZlWFZ1TWpjM2FFNVJSbkJsTVd0aVQzRndSM01LYUZWdWVHazFSWEZL
      TUhRdlFWaHVSekFyT1ZkRlNXOXRWR0Z4WWpSTlVqSlNkamRRU2xSaFpXWjZkRmhNYms1RlRFTjFi
      V3BWWkdOU1lYQkdlVWQyYlFwSlNtcEpZalJSYzJreVJWRkNNM0V5TmpGbmNVSnlXSFIwZDA1cmEx
      WkxWSG92V0VKd1NuUlBVRGRDVTJsck9HNVBOMEZvUzJsNGMzVXdja014SzJKR0NtSXZZblZLWTJO
      UGVYRTBiRFZRYVVwMksxVTRaR0p6ZDFSR1J6WXJNbTVvTTJWUlVVTnJVRUpGV0Zkb1dHeHlZWE5u
      UWtKWFVYaDJjMjFHV0hGVmEzVUtVbWR1Wnl0NFpIQlVXazgyVEM5M2NucGhiV2QzVTBoQlNsSTNT
      akpUT1RabVlqZHlVa1ZOVEdabU5ISlFUV1p4TUVwVVVHRTVialp6WTNkV2FFUlhhQW93Y0dveWVW
      cDJRVGxwWnowS1BXMUpXVThLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80655-4
    - DISA-STIG-RHEL-08-020120
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - PCI-DSS-Req-8.2.3
    - accounts_password_pam_lcredit
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM variable lcredit is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*lcredit
        line: lcredit = {{ var_password_pam_lcredit }}
      when: '"pam" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Minimum Length
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_password_pam_minlen,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_ubuntu
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Minimum Length
  hosts: 'tower.lab'
  become: true
  vars:
    var_password_pam_minlen: '7'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelpOZG5jMU9FUXJhalZ3VGtGUmFsZFdVUzh2VVRSa1Fu
      QmpRVnBWT0U1cmJqUnlPVUpyVkZKd1IyaHZhRkF3Yml0dFUwMEthMjEyUlhJMlpuRmtTSFJsUkVw
      VllXazVNakI0TkZSbGNuWjJXa0V3WVhoa2JYVmxRaloxTWpaS2IxWnFaSE5YZWxjd2EzTlNhbmRa
      V1RGbVdsRm5NZ3BuZGtFclVXRnFZV2hvZEhsc1VXdDVZblJVVkhOclFrRmxNWGhLTlVOM1ZFRkdl
      U3RPU205Q1EwdEVTRVpqVjJSVlZHOXlVVWxSZVZBM00zRmhhbWRIQ25BdmRITXJZVWgxVldGVmNH
      czBWRnB1UkRReVZrTm9ZMnBhWmtOa1NXSTRaekFyY1hGVll6VnBRa1pEZEdOTVRsSmpVMHAyWTFa
      aGFYRnVSRFJvVnlzS2VUaFJZMnRZU0RkNFNXUkZTRFJyZVZsWmVYRXlhR2MzVkZrelFXbG1VVzVz
      WTJ3NVdVUjVabXhNU3pNeWFHOXJTVU54UldOelZFbE1VWEJWVFhCQldRcE9SSGxCY0dOM1QycFFh
      akFyY0VsNVFWTjVZV05XY0dJNFUwOXBRbTFqTVRGSFpuRlFhemxvTVZSWmNrOWlOWGs0YlRab1NU
      TkhPRkV3TW1wV2ExRkZDbU53VVVsbVRtaGljVFZrTmtWNVozQkthVFpDVm14TWRGZzNaSGhEV2pK
      T2Fpc3hTMEZSVFc1RlIwVmFSVWRtWmxSbE1GbFRhVGszUml0RllXSlZielFLWjIxVVZVRmtTa0pq
      U2sxT2FrRnlSbkZXUmtZMGJFbEhPRU4xZVhvdlFTdFZORU56VFhGelJpdHFSbU55WVVsdFQzWndj
      bkpZTUhGQlJWSktUaXRrY1FvM1FsZDBZVEF6T0RJeGIyVlBlbXgyTDJsWFEwRTBlbVZQYlhCbVpU
      azBTRzF4TUZjeGJVZFlhVGxDUzNKQlQweHhaMEZoYzI5bVJWaDJaVlZLZW1oNENqSjJlSFY2YjFw
      WVpqVldNVk5SU1M5UloyMUNaWGhYU1VsYWRUVTBlbkFyVldVdk4yMXpLMXBTUWl0aVNtYzNSVmxK
      YVd4dVZHeHdNM1JXWjJwMmVHa0taMWRUVkUxVlJsUjZMMGg2ZDBkNWF6bHJZa3RqWW1sdVNHNVhU
      REZXT1V4WFpIWjZWMXByY0V4RWIxSklXRUZhY25aWGFVZEpSVzVRUkVkR1p6SkRjd295ZVc5TVVt
      cElVM1ZRV1QwS1BXUndNRXNLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80656-2
    - CJIS-5.6.2.1.1
    - DISA-STIG-RHEL-08-020230
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - PCI-DSS-Req-8.2.3
    - accounts_password_pam_minlen
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM variable minlen is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*minlen
        line: minlen = {{ var_password_pam_minlen }}
      when: '"pam" in ansible_facts.packages'


# Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_password_pam_ucredit,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_ubuntu
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure PAM Enforces Password Requirements - Minimum Uppercase Characters
  hosts: 'tower.lab'
  become: true
  vars:
    var_password_pam_ucredit: '-1'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelpOZG5jMU9FUXJhalZ3VGtGUmFGSjBkeTh2V1doS2Mz
      TldReTlIU0daMk1VOXphSGQyU0hjd2VucDNUMGs0ZUU1d2MwRUtNVkpSWkZKdU9GSlpURWszZG5S
      c01GQlhaa3RDVWt4eGVsZENlbWMwYzJkV1JFWm1ZbE0yWm1WREwyMW1ibTkyWkZnd2NtVkxVa2R2
      T1hVck5reDVWUXA2WlNzNFRXRkxaVFpxYm1WUU15dGlNVXhwUW5WNE5TdFhiRTVEYmtnMk5FcDBU
      MWw1UTNaNU1ISjNXbFpDY2tGRlRXdHdLMEUzVHpoMlVsQjVNV2hwQ214M1FuTnBTMVpUZDBaa1Nr
      a3daRGgxWkV0d1NGSldlRk5HVjI1RU5IcENRek5rSzNZMEwwVjNNVzlWYkRsT1lVeFNWelp3TDNs
      Mk5scExaU3M1Y0ZFS2NYTndaSFZoTUV0RGJ6Qm9aeXR4U2xsck9Fc3pNV3R3ZFhNNVJ6bDBXRWMw
      UlRWbWFqQlhTVTF3VW1GTVZFZGphQzlZUTBsTlUzRm1WemgwZDNCTUt3cEplVEowVUNzclNsQldi
      R2RIZVVOaVFuWk1WbUl4TTFJclJGRjVRbVJvY2xFMWNrdFpjeXRWWkRsSWFtSnVXRmhEYm5WRU9D
      OXdhVVZSVVRaQmJHdFNDblo1YVRObmFuQm5VVTVFWVM5MVpVeGxhbUZ0YkhRMkwyZDZOM1JpZG1o
      NlluTnVVMUZFZUZCRFRFdHRlV3N3ZFhkdlpVMDBaVU5IU3pkTk1GRlVkVE1LVjA1VVR5dEVkbmha
      U0ZkMFdtazRSbVJvT1dVMVpYUnpNVWRQY2s5T1JGZ3ZVR3d3VmpOc1RWZHJlR2RKTlRJNVoxUldS
      bEJDVVZVeFJqWlVVM1pIZEFwSWNXZHBjaklyV21GVFVERmFXR2Q0ZURkNWNHVTVRakZyUVZsMVYy
      OUNkVUpxVm5kaVdVWkNkR3cyV0ZKNk9VSnRXV0pvYm1ZeFkxbDNZemhHUkRGR0NtNDJjRXRhV0c1
      WU1FMWliVmhSUjB3eE0wMU5PQzl0TVdodFIwSlBjR0pSWjFwb1ZtdE5LM2RVTWs5MFVVaEVTbEo2
      ZFdkblNXWlVhbGhhY0ZOdVNIUUtNbVZEUzA0eU1EbEdNRVpSVFhKWVlrSnJTREJEYTNST2RVMURj
      MVp2UVZSTGIxQkxjREoyWlZoSmRHNVdjMDE1VVdKcGIyNVFNalkzZG5jdk9UWldWZ3B6VG1GRU1H
      VmlTSG8wWXowS1BYVnRVRWtLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80665-3
    - DISA-STIG-RHEL-08-020110
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(4)
    - NIST-800-53-IA-5(c)
    - PCI-DSS-Req-8.2.3
    - accounts_password_pam_ucredit
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Ensure PAM variable ucredit is set accordingly
      lineinfile:
        create: true
        dest: /etc/security/pwquality.conf
        regexp: ^#?\s*ucredit
        line: ucredit = {{ var_password_pam_ucredit }}
      when: '"pam" in ansible_facts.packages'


# Limit Password Reuse
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_password_pam_unix_remember,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = false
# strategy = configure
# complexity = low
# disruption = medium
- name: Limit Password Reuse
  hosts: 'tower.lab'
  become: true
  vars:
    var_password_pam_unix_remember: '4'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelpqZG5jMU9FUXJhalZ3VGtGUmFFVlJRa0ZCYnpGSkww
      SmFXbWh3VGtKaFl5dElXSGwyU25oekwyOVBhRFp3VDJaQkx6SUtRbkZ3TWtndlNqbE5UM1V2ZGxk
      cFdqRm5jUzh3V25GUVUxUnpTSEk0UnpOVmJXUk1ORVp5WVVsSWRFRTRSSFJwTlVKQlFrbGpUVlYx
      ZWpVMU4wcDRjd3B5Uld3M1duWTFTVGxQVVdOQ1VVaG9iMVJYU1N0UlJGcHlialowVDJKSFFtNVhR
      MlZzUlc5dEwzSTFjRTlzUVN0dVZHSnNUVXM1VFdKQlRtSjRXV3BKQ205NlptSllkVGt3TkVjM1Mw
      bE1hbFZsZUVGRlkzbGlUV0pCYUhkUVptaE5Wa2RxZG1KME5sSm5RMWxCYVVkQ1JVUnJSamxqTUVs
      VVNYbFdaVXhhYWxnS2EyWm5XV2RNYlU0MVJYWmpTVTVJV0VsSGQyRTFhVE5tSzAwelRVbzRiRFl2
      VVU5TGQwTnlhRE5HT0VOdmRHVXhVREY1TVRGcVdpOVJTelZRZGxwTU9RcHdRbXd5ZDNGNlZHRTFW
      RmhvUjNGaVVFMVdWa05HZVhCeVZGTklObmxQZW1odk5saHNjVUppTVZGdVNWaFJNM2x6YTJKTE5W
      QnhUVXRFTXpsb2NXRkJDbU5CV0RsNWFHTnNXR1JpU2tGd01ITnBla280WTFGb1JXeFZSME5KYmpW
      bFYzbFhXRnBTUkVGRWJ5OHdNekptVkZGc05YRmlLMXB4ZUU1eU9WbzJkRm9LU21aS1RYcE5RVGhv
      VDBOTVdXOUJRM0JHZVRkTmEycGhlWEZIVEhWblVVRkJkR1lyTW1ZdmNFOW5jVVpHY0hKdlIyUlNP
      RlpuT0RSVlZTOUtNMDVKY0FvM1lYUkdlbUY0TTNFcmRERnpabHAzU3pZelNETndZek5DWkhGc2Mw
      VkRSV2RaUTNGWGMwTnFRV2xtUVVoVVYzcFNLMFZZUWxwVVdGTndTbFpNYUN0NkNqSjRha3hMT1ha
      bGJrWkVLM3BhVEdWVGFWcENlRUpZYW5SNVNYaHFXbTFoUlVWUVZtMHdkVkp0VlVaclNrbFlXVTB5
      UWt4Rk5EUkdOazVNUm1jM1FWQUtSbWxQU0ZoR1ExVnlUemxUU21WRGNFeG9VMUl3YXprNFZFWnhk
      MnRtTTNoU01EbE1OakY1T0VaVVJVaE9NV05UUVdwR1MwVmFRVkZ0YUhaRFJsSnRWZ3BQYW14cFZp
      OUVkVXR6VVQwS1BUVTJXVUVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80666-1
    - CJIS-5.6.2.1.1
    - NIST-800-171-3.5.8
    - NIST-800-53-IA-5(1)(e)
    - NIST-800-53-IA-5(f)
    - PCI-DSS-Req-8.2.5
    - accounts_password_pam_unix_remember
    - configure_strategy
    - low_complexity
    - medium_disruption
    - medium_severity
    - no_reboot_needed
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Do not allow users to reuse recent passwords - system-auth (change)
      replace:
        dest: /etc/pam.d/system-auth
        regexp: ^(password\s+sufficient\s+pam_unix\.so\s.*remember\s*=\s*)(\S+)(.*)$
        replace: \g<1>{{ var_password_pam_unix_remember }}\g<3>
      when: '"pam" in ansible_facts.packages'

    - name: Do not allow users to reuse recent passwords - system-auth (add)
      replace:
        dest: /etc/pam.d/system-auth
        regexp: ^password\s+sufficient\s+pam_unix\.so\s(?!.*remember\s*=\s*).*$
        replace: \g<0> remember={{ var_password_pam_unix_remember }}
      when: '"pam" in ansible_facts.packages'


# Configure the root Account for Failed Password Attempts
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_deny,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Deny For Failed Password Attempts
  hosts: 'tower.lab'
  become: true
  vars:
    var_accounts_passwords_pam_faillock_deny: '6'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelpqZG5jMU9FUXJhalZ3VGtGUmFFOTZVUzg1Uml0VVdI
      VndXV1pWZFZwT1IyYzNkVFY1TURkbVVqSXJWa2xUUmxWVU5UQUtVa0ZvU3poRFRqVjVUelYxYXps
      elUzWkxWMWxaYVZGaWFFZFphVkZqYm5OVVUyYzNjMHhUZG1WbVIzZEtXRW94WkU1V1psVXlOWFU1
      Y25kMU5qSldXUXBZV0VsT1JITkJTV2RvY1ZoV1owcFNNRmgyZFZvd1RFRnFaekp6ZUhGM1dHMUZU
      MlpqY0dNNE1URjNkM1JOVEZReVdHOTBkWFZNU2pSTUszVnVZbU51Q2xka1ExZE1TSHBLU0RCMVFW
      RnpaMHRhTms1T1ptWTRWMDVSTTJ4TE1FMURNV3A0VjJoMVFqSmhRVmQzV0doNE5IZHpZekE0ZFRO
      SVdrSjFValJoY25RS1VIY3hOekJGTUhaR2JIVktSaloxY0dKWWJFMUtiVGRWSzBaT1NESmlVRUZU
      UVVGU1IwMUZlWE5LYmxsb1JYcEJjMVpsVlRBeGJqTnRkR3BvY1N0aVZncElPWEUxUlV4RlNWRmhU
      a0ZrUlVKMFZITjBiVmxtUjFKVVEwVTJiamhVUkdaWVVpOVliSEJqVUdWaWVWSTFZVk4yUlcxdGMw
      ZENjV2R6ZWk5d1FUY3lDbUk1VG0xUU4xcGlOM0pNWTJvM2JqSjBNSEl4VXl0TFEzcHNSRmR4WlZj
      d2QyUkVZeTgyTVUxQ05HRTJlWEp2WWk4MGFHVllUMFUxVTNGelpHdFpTRzhLWWtGTFYwVm9TMnR5
      U2xsNU5WWkhia2M1UlZGQ2VVNXZUSFpPWms1eU0xSkhXbUpxUjJGTE9WaHlOa2x1YVRoS2FVUlZj
      M1EzVFRkU1psTlVNMGRoUWdveFpURnBRV0VyYjNwVmFraFJhWGhKZWpGb09HZFBkVVJTWkdnME5H
      OTVZekJRYUdwc00waHNWVGxLYm5sQ2JVd3djRk4xYkZSa04xcE1WMWdyYVRZekNtc3lkemxFYW0x
      QlREUnFNRk5LWjBaMU1XOXlNV05xSzNkTWVuTllPRVJ2VFVvdlYzWTJibEkwTkhKUlZrUjRVM2x3
      Y210WWEyWnhVVlZzUkdONlRtRUtkbFo1WlUxTlQxVnhOSGh4VjNsc1RITTNhbXBEUlVsTk9HaGpk
      RVl5ZFM5SFR5dElaVVJ5V25RclNsSnRTakUzWVhWbmFIUkJPRVowVjBSNmFrVlZTUXBXVmt0cmFH
      dG1ObFZQYXowS1BXSkdhVVVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80667-9
    - CJIS-5.5.3
    - DISA-STIG-RHEL-08-020010
    - NIST-800-171-3.1.8
    - NIST-800-53-AC-7(a)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-8.1.6
    - accounts_passwords_pam_faillock_deny
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Add auth pam_faillock preauth deny before pam_unix.so
      pamd:
        name: '{{ item }}'
        type: auth
        control: sufficient
        module_path: pam_unix.so
        new_type: auth
        new_control: required
        new_module_path: pam_faillock.so
        module_arguments: preauth silent deny={{ var_accounts_passwords_pam_faillock_deny }}
        state: before
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add deny argument to auth pam_faillock preauth
      pamd:
        name: '{{ item }}'
        type: auth
        control: required
        module_path: pam_faillock.so
        module_arguments: preauth silent deny={{ var_accounts_passwords_pam_faillock_deny }}
        state: args_present
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add auth pam_faillock authfail deny after pam_unix.so
      pamd:
        name: '{{ item }}'
        type: auth
        control: sufficient
        module_path: pam_unix.so
        new_type: auth
        new_control: '[default=die]'
        new_module_path: pam_faillock.so
        module_arguments: authfail deny={{ var_accounts_passwords_pam_faillock_deny }}
        state: after
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add deny argument to auth pam_faillock authfail
      pamd:
        name: '{{ item }}'
        type: auth
        new_type: auth
        control: '[default=die]'
        module_path: pam_faillock.so
        module_arguments: authfail deny={{ var_accounts_passwords_pam_faillock_deny }}
        state: args_present
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add account pam_faillock before pam_unix.so
      pamd:
        name: '{{ item }}'
        type: account
        control: required
        module_path: pam_unix.so
        new_type: account
        new_control: required
        new_module_path: pam_faillock.so
        state: before
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'


# Set Lockout Time for Failed Password Attempts
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_accounts_passwords_pam_faillock_unlock_time,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set Lockout Time for Failed Password Attempts
  hosts: 'tower.lab'
  become: true
  vars:
    var_accounts_passwords_pam_faillock_unlock_time: '1800'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelpqZG5jMU9FUXJhalZ3VGtGUmFGSXlaeTgzUWpReVIw
      NHZiRFJvYkd4RlpTc3paWEl3ZG1jeFJVNTRTalUyVEd4V09XZ0tjMjFtZWxNd2NEVkVRa0ZFU21s
      SFVuazNhMWRtT1RGa2RrVnlTR2xoZGtSV2F6ZFNPV0ZOUkhSdVdtOUVaRmh5TlhKSVFWVnFObWxV
      YTI1MmNWQjVhQXBhTjJ3MFRHdFFZM1pqUWpoME1EZHlhbmh3VVZkWU0zbDVRM2x5YVU5WVEwUXpN
      VTEzZUdwblduUmlkVUZsYUhoSlQycFZOR28xYVVFd04xcEJZVkZqQ2pCb016VkZPRGx2ZG1SM04w
      ZE5iVTR5ZW10eU9FUkRWbUpsUTJZNWVrOUpOM0JpVVdJd1YxaFlWMWxxY25wVVRrbzBTbVJxU1VZ
      eE9VWmxNVE56YWtjS1VsVndSSEUyT0RGbFRFbDJUVGxpU0hOSFkwZHJabUoxTVc1eVRqUXZjVlZs
      ZDBSRmVXdHpWblpoZFVNMFozcGpXbGREUzJRelRWWmpWVVpNTm5sNGVBcE9NbWhrY1drckswTkdN
      MUp5WjJocVdXWkVVMWhKVTJkNWMzQnNXakIzTlVadlRXcGliREl3YmtzNFIxTlVXazEzUTBGYVlW
      ZzBlVE55ZFZCWFpVUjNDbmxDTDFjNVJHWmlMMGd6SzJZM2NVcHdXbHB0WmxOcFpHRldkbmRIYzJs
      c2RVOXJjRFJFVFVOdVFUSnJRVXRHUXpOTVMyTkRaMjV0TkdGSVEzaDJabWdLT1VWQmJFdERUVzFJ
      ZUhCWU5IQXJjM05YWjBOSGJFWTNRM2M0Uld0YWFFbHphRVJ6VHl0Qk5rRnJVV1I2VGk4MFVFNWFh
      M2gxVFVKQ0wwbEpaMnhLVkFwWGVVTjRVRmRwVEZGdU1tMUthRU0zWVRCTmQxRnBTRVpzY0VGV2Nr
      ODBZWEJIUldJdmNXeHJiMGxTWVRZMGNFcFVNRzh5UjFjMWNGWmxiRU4zVVRaSENrZHNSMlJqUVVZ
      eU5sWnZkMVl3TlRCQ1VUUkdNMmRYYVRoblUzVnFabGRPZW5wWWRVNWtSRnBsZUdGeU5IbGphbkZZ
      Y25NMVppOXNSak42UnpaTVYyVUtiRnBNUVc1dmMxUnJSa1E1Vmtvd01rcElOMk53VWk5SGFraFNj
      bTVDYWk5eGNUSmtMMVZZUkhSTk9EUnZWSFF4WkVjNFNVRlZSMnR0U1hjd1drWm5Sd3B1SzBvNFMx
      cFZURzVaUlQwS1BYazNSRmNLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80670-3
    - CJIS-5.5.3
    - DISA-STIG-RHEL-08-020014
    - NIST-800-171-3.1.8
    - NIST-800-53-AC-7(b)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-8.1.7
    - accounts_passwords_pam_faillock_unlock_time
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Add auth pam_faillock preauth unlock_time before pam_unix.so
      pamd:
        name: '{{ item }}'
        type: auth
        control: sufficient
        module_path: pam_unix.so
        new_type: auth
        new_control: required
        new_module_path: pam_faillock.so
        module_arguments: preauth silent unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time }}
        state: before
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add unlock_time argument to pam_faillock preauth
      pamd:
        name: '{{ item }}'
        type: auth
        control: required
        module_path: pam_faillock.so
        module_arguments: preauth silent unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time }}
        state: args_present
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add auth pam_faillock authfail unlock_interval after pam_unix.so
      pamd:
        name: '{{ item }}'
        type: auth
        control: sufficient
        module_path: pam_unix.so
        new_type: auth
        new_control: '[default=die]'
        new_module_path: pam_faillock.so
        module_arguments: authfail unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time }}
        state: after
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add unlock_time argument to auth pam_faillock authfail
      pamd:
        name: '{{ item }}'
        type: auth
        control: '[default=die]'
        module_path: pam_faillock.so
        module_arguments: authfail unlock_time={{ var_accounts_passwords_pam_faillock_unlock_time }}
        state: args_present
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'

    - name: Add account pam_faillock before pam_unix.so
      pamd:
        name: '{{ item }}'
        type: account
        control: required
        module_path: pam_unix.so
        new_type: account
        new_control: required
        new_module_path: pam_faillock.so
        state: before
      loop:
        - system-auth
        - password-auth
      when: '"pam" in ansible_facts.packages'


# Build and Test AIDE Database
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_aide_build_database,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Build and Test AIDE Database
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80675-2
    - CJIS-5.10.1.3
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-11.5
    - aide_build_database
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelp6ZG5jMU9FUXJhalZ3VGtGUmFXeGFkeTh2V21KM1ZH
      eE1UblZ3VWpGd1EzTmljRUl6Um5aNVJUZFdWVzQzVEhReGRrWUtNSG95ZVU1UlkxZGlUR0UwVERo
      UFVXVnFlVEZsTVZFMk1YSXdVa0pwV1c1dFFuaG1jMnBETUZsaVJVWldaSGt6VWpsMU16Vm9Ra1kz
      VVRsMFUwRkthZ3B5ZW01MlYwODVZVEp5YTJoUFEzUnlRVmxXV1dJMlRqRkdiblJFY1VGSlduQXdP
      RGhQVHl0V1EyNVdiMkZ2YTJKamFtb3JaMmxPU1ZWSVRrVnNMM0EwQ2psVFpIQnBXVEZaWkNzdlpU
      WlNhVTFQVlRsdlVIZDBiVko1Ym5WRlptZElPRzFvTVRsblRVUjRUbXQ2S3podFJIazJORmhZU3pC
      dlNWVTNlalowTDJFS1NXNURRVVZZUWpoVmRWQTFTSEoyTUdRdloydEhZVVp1UTFSUldWSnBSemhW
      T0RobU5ITXlUMGh2VFdaVWVXRm9kbVpCWjFFMmNrNTZiM0ZFTVhWd1JRb3lhRXBYYUhoS2FESm9Z
      MVo1Tnl0eGIyZFdiRFpxWjFKNmFGVXdXalZJU1ZGa1pIQkZTM1ZMWjNsWFpXeDBXRFpoU2tKeU0w
      MUlVVnBzY0doV1VHOHpDa0pVWVdSWWFXTnNPR1JOU0dwU1RYVlZaVkkxZEc1ek9EQnFWaTlIYm01
      clpsbFRORTFvVm1SS2QyTkJXRWQ0TXpOTVVpdHBWMXBEWVRJeGVHcEJNV29LZDFWM2MwbFJUMlox
      UXpabVVrNW9ORVphUWxWYVJrRmhiVUZ6WWtseWFucG5NVFZ2UldKWGVYUkRkRVp5ZHpKUWMyUkdS
      SGN3ZG1OWFlrVkNLMkpqVlFwUldEUXlUMUV5VjJGVGEyeENjRm8wV1hWVmMzZEtTSEJ2TVZwUVlt
      UmFXakZMZFhGaU9XWXlXVlUyVW1aWGFraDNNRUpyUlVGS1UxbDNhVTA0WjFaMkNqaE5URVl2VlhN
      Mkx6Rk5TVWhDTjJwSmNqUnBSRW8xVVVkdmVqZHNPVWxrYjJwd1dUWnRURkpoVnpseU1sSXliRGxw
      YTA5SU9VdEZla1E1U1ZGWk56Y0tkamRWWVhKbGRXeDNUVmxEUTBwTU4waHpXRlpuZFRsNlZtZGFV
      MmxGVTNaQk5sWXhSekJoTlhKR2VUZElVR2RWUjBGTlNrbFZia2hWUkdka1IycEhXUXBLVEhwalNG
      Um5NRGxvVVQwS1BUVk9NbTRLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Ensure AIDE is installed
      package:
        name: '{{ item }}'
        state: present
      with_items:
        - aide
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Build and Test AIDE Database
      command: /usr/sbin/aide --init
      changed_when: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Check whether the stock AIDE Database exists
      stat:
        path: /var/lib/aide/aide.db.new.gz
      register: aide_database_stat
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Stage AIDE Database
      copy:
        src: /var/lib/aide/aide.db.new.gz
        dest: /var/lib/aide/aide.db.gz
        backup: true
        remote_src: true
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - (aide_database_stat.stat.exists is defined and aide_database_stat.stat.exists)


# Configure Periodic Execution of AIDE
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_aide_periodic_cron_checking,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure Periodic Execution of AIDE
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80676-0
    - CJIS-5.10.1.3
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SI-7
    - NIST-800-53-SI-7(1)
    - PCI-DSS-Req-11.5
    - aide_periodic_cron_checking
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelp6ZG5jMU9FUXJhalZ3VGtGUmFWWjNVUzhyVFdNM2FV
      OUlWVk5CUTJ4SVJHRnNRa1pyVUhkS2IxaHFZMjV6UTNGcGJEa0tTVXREYmxwT05WTnBhRVEwVjFs
      V0wwRk1kbkJCTm1ab1dVWk1OR2hrTVVKaGVWSnhZVzEwWTA5Mk5uVk9Na1ZQVm0xMFNIcHBia2hs
      VmtOYWVGZGFNQXA2VkdGcmFtUXlkM1ZZZDNWdGMwMHpZM001V1dSRlFTOVRjWFpPY2pOVVJVeEtZ
      bWhQVnpVMlRVWXJRVVV4UVRWbFpuVnRNelF3Tm5FNGNIWjRRMko2Q2pnd1YxbDZTSFpIYTJSUk1U
      UXhPV3Q0T0ZkemVXOWhSeXRUVm14bkx6RnpkM0pqY1ZSNFlraHJMMDF2ZVZGYU5XOWhNVFZNTlRs
      aUsyODBhMDVXY0RVS1ZFRkNkRE53UTFCVWFsRkJXVXg2WnpoWlkwMDBUbkZ6ZHpCMlppOVhjVmQw
      Unk5S1QyaElUbXA2YVZjMk4wRk9aRU5XVm5oblZVSnlUWEJpYUhSMk9BbzRXVWhLUTFoVFRrSlpZ
      a1ZyVTBZMGRuaEdkMmxDYkVKUWFpdEpTM1p6YW5KbE5YZExTSGxRU0djMVdVYzVZUzltUzFwc2Rq
      UlBOMlJLVEU1T2FWVk9DbU5JZDNJcmRIUk5aVEFyUkZkUFIyVlJhelZvZEZJME1VVkxPUzl1TWtW
      VFlqUlFUVUpUYUdsbGFWQXlVbVp1TmxWWVJYaE5VVFJVWkdwUFRrNUphMkVLYWxSRk4wdExjbWxQ
      VURac1kzRmxUR00wYVRWWVlUUkxRV1ZrUTFoRk5FVjNSRUl6Vnl0RlltSnBOVTQxUkRrdk5FaGpa
      SFJ0WTFwTFZUZHpkMG95YXdwbU1YVmlhSEF4V0hRM2FEWlVkemxqVVZsb09XZFRRalZ1VjNaSVFX
      RkNOMUJJUzI5d1ZUbFdUMlFyZEZCUlRtRmxXalZhTUhoaVlYSkxiME5JYkhSTUNsRk9jRVEzV1ZG
      blFWVTBURkV2SzNkTUwxVnhTMHcwVFRWcE5sZDFXVGxMYTI1eE9IZ3JSVzlNZEVoQldFTXJUMXB3
      ZURKT01Xb3pjbVJ5UjNwd0syOEtORTVQWXpBclVUQk1WRkpwY1dVeWRuSjBTRlYxYVZKelZYRnhN
      RkV6UkN0bkswZEJXRWR2V0dNMWFEaDVRbUk0ZGpnd05HNXdSelpwZEc0Mk5EWlpWd28yY2tocmRF
      OVhWVVZVU1QwS1BUbEdPWFlLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Ensure AIDE is installed
      package:
        name: '{{ item }}'
        state: present
      with_items:
        - aide
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Configure Periodic Execution of AIDE
      cron:
        name: run AIDE check
        minute: 5
        hour: 4
        weekday: 0
        user: root
        job: /usr/sbin/aide --check
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Configure auditd to use audispd&#39;s syslog plugin
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_auditd_audispd_syslog_plugin_activated,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Configure auditd to use audispd's syslog plugin
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80677-8
    - CJIS-5.4.1.1
    - NIST-800-171-3.3.1
    - NIST-800-53-AU-4(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.3
    - auditd_audispd_syslog_plugin_activated
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUZ6ZG5jMU9FUXJhalZ3VGtGUmFuTnpkeTh2WmpjNU4x
      bHRSbFU0ZUhSVU9VUlhWemRZYzNkM1pEWnJZbWhrT1N0MVZWb0tZV0UxV2tsdmJEQXlPVXhoVkhC
      S2NrTmxWa2xxU0ZsNmJuazBhblZPTlZGeVJqaFhNMUZITjJKckt6ZG1aa1YwSzNkc1ZtdGhZMVJS
      WkhVd2VHTjJTd3BRVm5wNFFuaEVPRU5hTlZaTmNsVkVWbEZxYTNCV1oxUlJXalpUYms1UWJHVlhN
      M2RaVUZsaWFERmpVVU42ZDBacE1FZ3dNMkpHVUZacWFYaGxVMWRHQ2xwTlFsTmpSRFo1UWtKMFRV
      RmxWbmtyVVZvNVdIcEhabmM1VUROc1kyWkhWbHBSUVZocGEwUkNWRnAxVFhKd1kycFZlV1I2VTNW
      cGRGUk9SbG8zU25FS1NXRlVTRkE0VmxWTWVtSnFWVkZ6Y2xWMVVreGtjVzVNVTJGcFdWcGtkM2Ro
      Ym05eGMzZzBURFl5YzA4M2QweDBRbXM1YVU1aVJEWjBibEk0TjJSTlpBcDJjakZXZW5WSFNtVTVa
      azlHT0ZaUmVDdGhjblppV0dGbVl6QjJOa0pIZGxkSmN6TXJUMkkyWXpGSFYyVlpRV00zTkVscVJY
      cDZkRXgwVFRoQk5EUnZDazF4Um01aldqRjROMEZhY0VWeVlURlhUbEJTU0ZnclZqQXpORUp0Tmsx
      V1MyUkNWRFJZT1VkQmRXWXJkV3hOYTAxWlYzRk9ObXhZSzFOWVkzWkdSbFVLTjFGaVJGTnZWVXR6
      VDA1clptUnVNRmREUTNkaGJIbG9ZWEpwYVcxNWVVUldNQzlTTjJsNkswcGxjM2hRYTFsRGIwbG9O
      bUpaTkhoeUx5OU5SREkyUndwU2QwTlhSRlp5S3k5MFV6aGhXSGROVEhobWFWaG1PVEpzVkcxQ01D
      OUxjbFZHVlVKU01sRk1SRXBqVUhWWGVrdFJjU3RQWkRCVGJITlpRamhIY1VWWkNrWnlOV28zYlZK
      UmEzSnhSMk5ZUjNwUllWZE5MM0J3Ym1OaFVtNUxVa05UWmtsaGRrNWpTa1pqVTFVM1pGSjJNbXRI
      Um5NMFJYUlNUWFJQZFVjM2RrVUtRMnhWUVZvNGEzZFBTRXhpWnpSR09VTlhiRlJrY0d3dlIzbzBU
      MlZKTW14bWVXeHljV0l3YmxOblJ6aDZSSFJFVEdZNE1tazVhWEJwZUcwcldXcHlUZ3BLTUdGNU5G
      WmFjV3czZHowS1BYWkVTR3NLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: enable syslog plugin
      lineinfile:
        dest: /etc/audit/plugins.d/syslog.conf
        regexp: ^active
        line: active = yes
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Configure auditd admin_space_left Action on Low Disk Space
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_auditd_data_retention_admin_space_left_action,fix)
# Version: undefined
# platform = Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure auditd admin_space_left Action on Low Disk Space
  hosts: 'tower.lab'
  become: true
  vars:
    var_auditd_admin_space_left_action: single
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUU0ZG5jMU9FUXJhalZ3VGtGUmFEZDBkeTg0UkdWUlNI
      SnFhaTltY0ZsTVkzVmlSelJJU0VkVFJtNUdNVlpETUhONFNuUUthQ3RCYkdOMmFuazFVRk5MT1Zk
      UWQxVXhjV05GZUV0SE1FMXpaMHRyUlN0a1QyOHJlRlZRZUdNeVoxbHlUM2wyU0hwQmNrMXJLemxU
      WjAxUWFXTlphd3BzZWxsWVRFSlllbUUxUlZkdlZXRlNiR2R5TDFsQldrOW1Wbk5WVDJkWk9YcGtO
      U3MxVEVsbk9FUTFSa2t6T0d4cmIzcEtMMUJrTkZoVlVWWjRObE5EQ21NMk5YazJNM0pqVmpBd0sx
      QjFVbTVuUmxKb2VUSTJSRkoyVVZZM1FXazNOR0oxYkhJeFpIaE9XVlJzUnpJM1pIVlFZMHMzUTNG
      eWNEQXZaRGgwVjFFS1VFRlVXRTlYUkRSaE1TdG9lblYyWVVKcVl5czNOVWRuTmtkck9XVjFWWE5P
      UkRkV2FFWjNVbWxCUkhwS1FXSkZja3QyYXpsS1FtODRhMkoxZUZwU1pncGtVVzFWTUdOQ1kxYzBN
      RlpNYXl0cFdTOWxhMk41VmpJeWFYbHZjemxhUkRWRVdGRjViMlZ1YzFVNVZFazFTeTlQUzFsVGFE
      UnFZM2MzWkU5TE1UZG9DakJ1YXpCdlREZFRZek5OYUdzdk1tRnViV2RZVEhkUGJWSnBRbXhIV1hS
      NFlVOW1OMnhZVm5CWWJqWk1Sa2xtTjJ3MFN6TnZWemRpZUhrMldTOUlibk1LYXpkU1p6UklZVlp6
      TlZNd1J6RkJhVTQxT1hoWGJ6QXZRbVpFSzNaV2FHOHpia1E0U0ROVFIxSlJhakJGUVhCcWQwZHNZ
      a00wVEdSWk5VNUJialJPVlFwRmRIQmxOamxoYTBWaFpDODBjWFZqUWtZMGRrZGtiSGh5Y1VZd1pH
      MUdVa1E1TjFkUWFHcHJPVGx0VmtremNHcFNWRnA2UjFSdFpUVlhaR0ZEYTNabkNqWmhUa3hrU1ZG
      S2RYRllVREpMWVhkMlVIVlljM05tVDNoNmFHVjROMk4zTW1vMk5ETjRWRFJZYnk5R05ERnRVME00
      ZUZnME1EbGhTSEl6UlV4TU5Ga0tUbXdyYm5rNGFUY3ZPRE5zY21oc1pHaGxZVkJJWW5kcFVIUk5W
      ekZVTkcxaVYyWnNWSHB2SzA1Uk0zZHBRMUp6T1RZM1pFSXZSbTFtYm5SV1NrdE1TZ3BuY1ZSUVdY
      UnhhbEZOVVQwS1BVTkhhWFFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80679-4
    - CJIS-5.4.1.1
    - NIST-800-171-3.3.1
    - NIST-800-53-AU-5(1)
    - NIST-800-53-AU-5(2)
    - NIST-800-53-AU-5(4)
    - NIST-800-53-AU-5(b)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.7
    - auditd_data_retention_admin_space_left_action
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Configure auditd admin_space_left Action on Low Disk Space
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: admin_space_left_action = {{ var_auditd_admin_space_left_action }}
        regexp: ^\s*admin_space_left_action\s*=\s*.*$
        state: present
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Configure auditd space_left Action on Low Disk Space
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_auditd_data_retention_space_left_action,fix)
# Version: undefined
# platform = Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Configure auditd space_left Action on Low Disk Space
  hosts: 'tower.lab'
  become: true
  vars:
    var_auditd_space_left_action: email
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUpOZG5jMU9FUXJhalZ3VGtGUmFqZ3hlRUZCYUZKTkww
      aGpkR1ZIUkRSQmNtTXJVVXhYTjJWbk1WY3ZXR2hvYmxOS2VVRUtSaXNyTUZGWVlscFNNVU5YSzBs
      WVNFWkxWa2t6WlRSUFpVMTBObE5KUkhkVlZ6SkVRaXR5VFVOa2RtTnpWRzFvZERWRVZWUnVkVWRw
      WmtaMGVYaEthUXBhTWxGTlFtaHRiM1ZxWmtWemVWUXZOa3BWWW5kRFZ6aDJVMGxGYldObmFXSnlU
      VFJHTjFOTVNuVnZlVEZvY210VWJtaEhhbEZzUjJsaE4xWkpMMlJwQ2pONlpqWXpVRmxWUWtSMmIx
      Vk5NVmxEVjI4elQwUk1hRXgyZW5wTVVXRkxSMDgyUlZsWk4yMTNiME5wYTJOaE9UUmlUbE5QZVds
      SWNtWjFhRVpHUzBvS1ltaDVMMmxSUWxWaFdGWnllSEJNWWxwV0x6SlZPVTF2WVZCVGEyOWlPRFZX
      T0M5bWJEZHhlVGd2WWtsUldWWndkMUZIUVU0ck5USllTblJEZWs0NVl3cGhUbmRTU3k5NlYwVnVS
      R0ZDWTBwbGIyWlBja2xTY0ZaaFIwVlFkbUZUYVZJNVRXZFFValZqUVZSS1RGaGxZbGc0TUVGMk1X
      d3hVRlJhU2paWmFETm1Da3N4VFM5RFp6aFpaREJWWWtOUmIwSjZiSHBxVDFGbVMySkxObXBIWlRN
      eFVrcDRNMVJCT1RkR1pETkdieXRLTVhsek9VbDBURVIwYlVOeU4yMUVhMUlLZUhvM2JqUXZhVXBt
      YVU1T2QzRkRPVUpFT0VZNE0xQnZWV3RzTkhGRlNsVkJkVUl3WlU4eVZXTk9PR1JRYUc4MVZXeE9a
      VlJyY2tWTmFtcDRUbXhJWmdwc05XeFNSSGgxTmtaU05rdFhiV3hDUVhwcmFtNU9TbGw1TUdGTGEx
      WkJWekpNUml0SUsyWnVLemRKVDFOMVVtVlBORTUyVWt0RGFYQTBObkI2YmxscUNtWnhUR1ZhZUV0
      aFZFRlhTa3AxWWpSR1kycFRNRzlJU1Vka2FYUTVObWRRVlN0c1NrSXpOVUpLYjA5aWVVeFJhbkZL
      V0RsaWN6bHNZWGd3ZG5vMlptNEtiVFJwYVhabU1GSktTbk5rWjNnMGJqVlFlVEZMTmtVM0wzQkRh
      a3RFZEZGVU16WkhaRGxVZFhFemIzQnFWSGMzVkZCM2NsVnRhM2RSVkhvdmJFTndOd3AxTWxWek1X
      TlpWSHBzU1QwS1BVTk9Ta1FLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80684-4
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030731
    - NIST-800-171-3.3.1
    - NIST-800-53-AU-5(1)
    - NIST-800-53-AU-5(2)
    - NIST-800-53-AU-5(4)
    - NIST-800-53-AU-5(b)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.7
    - auditd_data_retention_space_left_action
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  tasks:

    - name: Configure auditd space_left Action on Low Disk Space
      lineinfile:
        dest: /etc/audit/auditd.conf
        line: space_left_action = {{ var_auditd_space_left_action }}
        regexp: ^\s*space_left_action\s*=\s*.*$
        state: present
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record Events that Modify the System&#39;s Discretionary Access Controls - chmod
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chmod,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - chmod
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80685-1
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030490
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_chmod
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelk0ZG5jMU9FUXJhalZ3VGtGUmFVRllkeTh2WVZsS2NY
      ZHZUeTlVU1U1b1VtZEROV3hGVVRjeVZYZExTSE1yZFU5M1JrY0tNMU5OTURBeGQwZDJSVWRLVjFR
      dkswVXphMkY2TDNkc00zWkJNV2xIYkM5dGJXTjFRVkYwU2xwR1FWRlFWRkJ0UW5kWk1GVkJPWGhX
      YWt0UGJGQk5jUXA2TTFKblRXaDFWRWc0WTFaMFowSTVMelJqZGtocmIyeFJVR2QwUjI1Q1owMWlV
      MVYyUlN0TmFHcG1Tak5XVUdJelFucFZkVVZ5YjFSQlpURm9SbU5JQ2xGQ2RXNDRkMUl4ZHpCc2Ey
      VlFlVlJ3UVhOaWFtMUlkekpRY3pWMmEzQlBSbGhKTHpaVFkxWnBPRTB3UTBkdVZqSlJkVmQyYkVJ
      MUswMDRTbkp4SzNNS1FYWk5OVXR5VW14MldVNHpTblJrUlcweFNuRlZUM2RhZUV4eWJYSTRNalpr
      T1ZsNWQzVkZkVlJ6WlRGTGJYSkpOelJYY2twUFZESjVOVWRSUm1aWlRRcFdWa3hFUkhSSk9XcExP
      WEJUUVZaeVVrTXdWMjFMVjJkMGJHdHRUMVIzVVZKdldrZFNiVmxaV1dOMFIxUndlRGxJZGtaaFVG
      Wm1aV1ZxY1RWcGJHNDBDa0pyWlV0dVNYWnpZbEJrVEhwRWFVTnBaRUozVG5GalkzVk1WSFZRVGxw
      Q2NIY3pNMVpvU25wb1pFVktORWxwYlM5YU1XaGtRV0Y1VnpoeUt6Um9WelFLYzNsSE1FaEZWbXh2
      YzJwUlpEbG1SVU5rZW5kM2FrNUJka0YyU0hsMlYzbDBjMFZXU1V3MlZEQXpXbXRoU3pVelQwOTRa
      MlJXWXpoMVowVmFZV3RPVVFwMFdraFJZWEUyVGtKb2FFTXpSbVJYUkRKU05FWXZUMk42VUdKa1dF
      RjVUMnRvWm5GMmRIZDBTbEJxVW05VE9EUnNZMnR3TTJod2REZEdNVlJhVmtRMUNsZDJXVlZQYjFW
      RlFtb3pka3AzZGxRdldEVnBabTQ1YzNNeVNqWklXVGdyTlN0Wk1HUlJkRnBpZDNSa1JUUnlWV0Z4
      VEhweUwweDJRVWxPUTBOQ2FDc0tURTlLUVc4clF6TklSak01SzNVMlRVRnJaR3hpVWpOd2VTOW5i
      MWxFYTJScFVFWjBVMjlpV1ROVk5YVXZNR0Z5Y25kUVNGcE5TVmxoWlhFNVdqaFlXUW96UW1KalNX
      TmpiVTkyYXowS1BYZEdhVFlLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit chmod tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for chmod for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for chmod for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of chmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - chown
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_chown,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - chown
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80686-9
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030480
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_chown
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaelk0ZG5jMU9FUXJhalZ3VGtGUloxSnRRUzhyU2pONU4w
      Y3JVRFpKY1VWUE1IWXlkRnB0U0RabFMzZGtXbmRoUzA5M1RYVUthV1ZrWm05M1JraGtSbFpTY2pk
      VU5HcEJhalIxZVdaa2EwVlBaMWxHWldWRFFUZFlaMG96UTJSVFVITk9iWEZzWjNkVlRuRXpZWHBC
      WWsxSkwydGlTUXBrTkhKNlNXTnBVMjQzWTJFMlVHSkpLMU01UWs1eU5tOUpVVGhMY25wbmQzWktW
      WEJESzFwaWNqQnBVa3RoZUdKSU5sbFJVMkowV0hsS1VXMTFlbk50Q2tFMlZqQlBTVmgxYjFWMU1q
      Sk9Ta04wTmtkQ2RYcElXWEp3TjA1dFdscEVNWFZRWWtNMU5tbzRUMlpvVGpCdmFuUjZaek5hV25W
      VWJrTmtTVGxzUVZZS1RGVkRjbFk0VHk5bk0zTndORGQ0VTFablRXSjFUakJWYlhaQllUTm9iWGt6
      Vm1Fdk1HTjJiMkpaYW5rME55dFJhbFV3U0dka05YSTVVRkpPY2psUVRRcEpObmx6YkdkQ1dqTmpW
      RTFwU2pkTFoyVnRWVlJOUkZkUWVuTjNjSHBJVERKWGRUUnBVMnRxUzFaSmVEUnhPSEJQYTJkclYw
      Sk5NVzVNT0ZOV2JXMXFDazQwTDNwQ1JYTlVNelpUV0dzeVNVUkxXbXA0VG10Sk9IUmlSa1pUTWtW
      cWRqTlRjRXRaVVdOUWFYcDZZak50S3k5SWJERndPRW93VFhNM2FtaHlVeXNLUVVaT1RtWlpXbGsw
      YXpWUWFHTk5aMFpSVmpGTWIwcDVhRXQ1VTIxdlIyRkhTVWxyYUZGeVpXWk1aVE5JYkdoU1Z6RlNW
      bGhRUVVaaFpYRm5aVnBVYUFwM1FuVlNPVGN3YzBZMU5HcGhhbTFUUzNoR00yMWhWVVpCVTNScGFX
      OVBabEZFV25WQlJWRlpZbGxzVDFaUmJGcHdZelZLVGxoV05tRklkbWN6Y2tWTUNtNUdNRTFwVlVO
      dkwzRkhNbEZ6YlZaUWNUQk9UVVJ5WjNKT1NFbFpNblpwY1dwTWMzSlhNVkl6ZEhKMGFYSTNUWFky
      YmxCYWJrTnhhVFpZUmxSdWRUQUtNWGQ1TVZsNlNtUk5abEp4ZEVsV2MzQlpkbFkyV0hKRlRFSTFh
      bkZ0ZUVsUWVqRlVkVmcwZGl0a1NVeHBTbXBLT0dwbGNuSnVkbVYwUTBkR1ZUWlFid3A1ZEVOdFpI
      cHdjRmRoTkQwS1BXMUpUallLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit chown tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for chown for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for chown for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - chown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of chown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - fchmodat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmod,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchmod
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80687-7
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030540
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_fchmod
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemROZG5jMU9FUXJhalZ3VGtGUmFXWTVRUzh2WW1wSFVW
      UllVR0V2WjNOcVpuaHlibFI0TTNwTVFTdFFObU5WTXpaNE5IRUtZWEJVYWxSUVVDOXJSbGR4UlUw
      NFYxbDFWV3BhTVdkdWRrc3dOSFpyT1ZrMmIxcEViSFpQTVVScU5VTmFXV2hLV2tOQ2FEZEJNMHhT
      Vkd0d1pWVnFNQXBST0dOU2MyRm5WWEIwZFhVM05sWm5UMHc0UzBoWVpITnJOa04xWjJkSVRtazNW
      RzFGZUVGdWFXWlNMM1ZvWTNGRFdVNHhTazlOVDJ4VGR6aHdWVkpVQ25sWFVscHhhMHhOYlV0RVYx
      QXJUbXhIWTJWVU1WSnFTVVozTkVjeWFsVmhNREJCZWl0R00wWmFhMEpOZFd4bVpYQXlkVWh1UkZK
      bWVuZHllWEJNTVZZS2EzQnJjMEZqUjBsRVJHeEpjV3RqUW1FeFZraFBORzVPVmtWU2FqZHhLMGxp
      VWpaMU1uZzVabms0VmtKT1lqaENaVWxSVkVGeFRtUlVjMmhoVkZoYU1ncFRlVEJ5UTFoMFlVaFRR
      elJoTUZZNFdFMTJSWE54ZVZsYVluSkpUbEYwYXpCcFoxVlNVa3RSUzJWUlNtTmllakJIVTJSWGVr
      OTNjVFYxWkZWVlRGRlpDbHB0TlV4aUwwNUllR3h5ZDNkR2NEZHFjVXhuVTNaeGNrdHdUemg2YUhC
      MFRXSlNibVpFWTBkeE5Dc3pWM2RQTWxCUk5FbG9WWE53TldJeVMxWkVNVU1LUVhaVVl5dFBXRmMz
      T1RNNWJXZFRibXBOWmpoM1NGZEdWbFJNTjFSTGRsZEdTazlEY0hGcFIxWmlPVVJSZFRGMVJ6Um5V
      VmxuYlU1S2JqbEhTRE41VndwdmVIZFVjMWRqUlZWR2VGRjNlRUpHY1dOUGFsWnhXV0ZMV2sxeE1u
      Y3JZMFo0T1dKaGVYbDRMMlZuY3pWVk1XOUxhbWRpWms1d1pFWm1ZelJHWjFGMkNtZHNUbk5JY0dO
      NWNXeHFNR2xPYkV4S05HMXhkR2xhVlhnNE9GUldVVFZuWTFONlNESkpORTluWXpSMlZXWlZOV0p3
      VDJGTlVrazBiMFV3Um1GUksyNEtNMkpGV0drcldISjZjRGxKTTNSUFRqUmtUMUZoYTFSTGJYRlpV
      MlV2TlRrMWVrNUVOWEpDY0hsTmRXUmtXRk16TDJvMFVHRlphRWhtYUVKblFTOXFaQXBZUVZZMGFF
      NDROV3Q2TkQwS1BWRXZhVkFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit fchmod tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchmod for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchmod for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmod
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmod in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - fchmodat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchmodat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchmodat
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80688-5
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030530
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_fchmodat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemROZG5jMU9FUXJhalZ3VGtGUmFtcFpkeTg1Um5sblpu
      aE9TRWxJTTJ0Q1dFczNSVkpHVTJaWU4xUlZNVXMxV25SaVVFWUtielU1U0hONmNXVlJVQzg1SzBz
      clFtSlJNa3d6ZFcxeFVrVkxPR0p2TmxocVNrMXlabVJ0V0ZCS1ltMVVObEZ2U3pZemJUZzRTVFJX
      Y2tadWJtUkhWUXBIV0dRM1MxbFNTbHBqZURoQ1NWZFpLM05WZVhSeVpHWTVNbFpYUkdFeFZFWkNO
      elozWlhwWlZYbEJhV3RrVmxSUFZsRTJPR2QxWWpkd2FFcENjMnB4Q21aT2FFOW1kelYzU2paU1JG
      SjFaa3d5WjJKTlMxZzJaMmRMTTNRMlZITkVWa3d5VWpseWQwTXpWMUJKVERWVk4wVkJjbVZLTHpK
      SE1XWkxSSFkyTmtnS2VuTTJaSFIyTVRKUWRtcE1Xa1VyTm5GWU1HRlliMmN5YlhaVU1pdFNibWhP
      VVcxYWVrVk1aRko0U25sUk5FTjFRbk56YTNsc1dFWk9lVXN3TWpaVmR3cDJjelJQZEcxa2JrZFdi
      bEJsYURGWFEzRm5SMmR6Y1U4NGNVSXpZVzVOWjBKVllsUk9hRVJwUlRaVmRHNDNWR3B0ZW1SUFZX
      OU9TQzlRYUZkSlF6STNDalJIVldSc1pFOHdOazV3SzJOdEwydERWMUYwVVM5VFNIUTBTbFZTTkd3
      MmVXdFVkWFZ4WjBaTmFHTkNVekpsZWsxc2JrcE9la3h5UzNCdllUVkdNMklLY0c1clNGbFpkWFZy
      YVU5WFIxcDNVVXBST1hwVVYxTnFVQzlXYWxaTFNtWnlLMDVTT0V4NlZqa3JaazlYT0RaSE1sbGlN
      RGwxWlVGSmIxUkhlUzgxT0Fvdk16SnlTWFI2ZFhsaFozVnVialpGYzNacE9VWlpVa1l5ZHk4eVEw
      TllVWHBKUzBWWGFtOW9aRkJpTkdGdVQxSTVNMWd3VlZnME9IQnZjRUpCZGpkNUNtTkhiV056ZWxJ
      eWVWaGpORTlyU0dOeGFXRlNOazAwZEVkTU1XcEJWR1ZDZGxCS0wzQjJRbFpSUVZGR2F6SjBRbm80
      V1hkaVNIa3paM1JtWVUxMVkxb0tjU3MzVDBFeWFrVkViMU5DVVhBMlZsWlBNVkIzTVdaTVYweHlh
      MnhKT0RSWGFERXZNRVJwWkd4MlRWSm5WVEpRY0c5bVFWWnJVMFl4U1VadWFYTnlNQXB0Wkd0ekt6
      WlJObGszT0QwS1BTOURXRGtLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit fchmodat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchmodat for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchmodat for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchmodat
            syscall_grouping:
              - chmod
              - fchmod
              - fchmodat

        - name: Check existence of fchmodat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - fchown
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchown,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchown
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80689-3
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030520
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_fchown
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemRqZG5jMU9FUXJhalZ3VGtGUmFrMVlkeThyVDJ4NVR6
      UjBVV052TmpSS2VHMVZhRGRNY2xKNVdqaEhiVGhpTDFCRGJEQUtVbTE1VG05NFVVTndSamxKUmxS
      VU9FbG9TREZ5WjFSQ05WRTNaMHRsVkZsMGMxbzJaVTB2VDBKVU4wMTVjV1pFVlhoMVpWaHRReTh4
      U1d0bVNEVlhlZ3BITUdwclRraExUMEV6WVVwT1oySnBTV1JETTI1d1JYbFNWbkprYlVGVU9HMVRV
      aTlhYzBSbGQyRnZXQzlRY3pnNVJIWldOaXQ2VWl0dlZqaFFSVFkzQ25GbVlYTlJSbEJ3TkRkTk0w
      MVlZaXQ0UXprd1RqWndhQzlZWlU1VVNUa3pSM28xY21Ob2RrTjFXbFpNUkhoYVpUWkhNRGRXZWxR
      MFVUaERWSG8yVFZvS0wzVnpNRUkwWldGUVIzZHBlazkzUkVvNFkyeDJOVTVRZWtnMVVYQk1XbEp0
      Y2xKblRsbDNSRVJZVkVoWGRFbDZObVY1Ym05YWRUSjFUR0ZLUjJObFFncE5PRVZoVTFRNFpXZ3JR
      bmw0WWsxNWQwUk9UbTVtUlRobk9FMU9VVUpuZFhKQmEyRkVOak5SYUhBNE5ETjVXVWhpYjFaR2Vu
      ZFBibmhTTjBrdlpHNTBDbVJJV1VSaWMzcHNXbHB0Tm01R1dtMXBkVU5GVW1kdVRtaGFOekUxUVhk
      M1RtVnJZbEJwWW05V0sxcFlia2hqUlVWRFZIRXdjMmd2SzBSME0yTkZTMUVLYVRRM1pVVjBabFp5
      VVVGdGFHNVVhWFIzUVdwblpFaDNWbFI0Y21zclN6aEdXbXBDUVZWWU9FaEJRbU1yUmpSWlpHWlFN
      RXB0TjNJMFEyWnBRa3d4U2dvdlVGZG1ZVTgzWjBVMldFZGlUR3cwZWtGdUsxVktPRFppTm05dlJW
      WXdWamgwYmxSM1QxVnhkemMzWkM4MlJtVnJaV3R2YW1GdU1XZHVZMms1ZW1OckNrVTNiRmt4Y1VN
      ck0xSnFURmx2T1Zwc0szQkNVblJHTWpGbUwzQTVWVzFzVjNCT01GUmxUVlZFWVRCeVoydE5RbTkw
      TlhCUlZFUnphMnd5VFV4alMyNEthbnBQTldKQ1lteEJWV2RFVkVKck9IRXJTbXhuVWt0VFpreG9P
      RVJ3ZWtKUk1YbHpkWGh3T0VsR1JHcExWWFl2ZDFWeFluWm5SemRQT0dGMWN6VkRjUW95VVVoQ1ZV
      aEVhSGszVlQwS1BVRkJjR1VLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit fchown tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchown for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchown for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - fchownat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fchownat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fchownat
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80690-1
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030510
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_fchownat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemRqZG5jMU9FUXJhalZ3VGtGUmFuUXhlRUZCYlRreWFI
      aGllSEZFTkZWakwwaGxWa0ZHY1ZOMWMxVlRUV3g1YjA1dlIyVUtWbGhrY0haSU9VUXhXblpVYmxo
      Mk1UUTFlREp4ZDBVNGFHdExibmgyUkhrd1dTdHFVRE56TUU5cGJWWXlSSGxoT1U1dU5ETkVUMGQw
      V1dKTE1UTlVNQXAyWlVSMmNtbGpkSEZKY0RkTlVXMTFXV1poTlZCMVJreFdjVFJFSzAxUFQwTkRX
      WE14ZUVkTllWUlFTMnBhWTNwa1MyZEVTVWQ0T1dObEsxbFdVM2RUQ2s5bWNHSnBUVFZuVEhRcmFq
      QndPVU5FU3pkWWNqUXZhRE5KTTBvM2JrRnFRMDB2ZFdzNWRVTnFUamxTTXpOdmVGbEtOVmRuV2to
      TFFVNXdlREZ6VmxNS1NDczRRbWxYVFRVd05UQktUbG95UkRWVGIxQXlkVWc1TmxobE1FazRORXhK
      Y25GMVduUXhNRzlDWVc5blExSmxWRTlpUzI1dGFsQlVheXRhVEhCME9BcDVkRVl4TkdkNGJUTmpT
      bWRZU1hoU01WTktOMnhSV1dRelNuSk5SRzVDT0RKUlRXRmliakF6ZHpaRFVYVnZaSEZ2ZVRocVMx
      aGxWRWhNV21Kdk9UUkZDbEZSZG5sMU1FdFdSbUZHYlVsdGFYbHFRWEJwVlRab2VVVlhjak5UWjNC
      Q1IyZHNUVWRUT1hoeVJFbEJkV0k0YzBKQmFYaHBUV3ByZEZNd1dXOVRiemtLYkU0eGVIVTBXWFZD
      Tm5sSFNFMXFOVTVoTDFWT1lqWkpSMGRMYlRORlJrMU9UVXgwWWtJeWJsVmpORk5qZFdSdE5GSkdV
      emxhT1RFMWEydG9VRFJvY0FwSU5qSnNSVlEwV2pSWFdFWm1VMlI2VGxCcFowSnpPV1V4TlRBclZW
      bDRaRkJXVXpKdlRXMXRRWHByTUdoNE5UTjZPV3hNVms5c1drTmFNVE5DUkVOMkNrNXliM0V4YkZk
      d01FdDVaVGMzVGxCTlluRklUVnBvVkcxUU5IaGlSMWhUYVRKR1NGWjJURkZqTjNCc2VFZzRaMHR4
      TWxoNU1ETkxlbWRUTmxCNFYwd0taMmRHT1RkalZXTkVSRlZ1UW5OelFtTnBSVVZ6WjBOUlFrbFFZ
      bU5oU0M4eGJtRnpZVmhFU0dORU1VTnVRWGd5ZDBzMmJUVkpkMkkzU1cxcmJYQXdMd3ByY1RKdVpu
      QnRSa1ozT0QwS1BWZGxZMFFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit fchownat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchownat for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fchownat for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fchownat
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of fchownat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - fremovexattr
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fremovexattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fremovexattr
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80691-9
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030240
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_fremovexattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemR6ZG5jMU9FUXJhalZ3VGtGUloyaEhaeThyUzB0VGNt
      cFdhVFJpUkcxQ01qWnBOR3RsVnpGU1ExYzRlQ3RTVDNBdlRuTUtlVlJXZFVWQlVVdEtMekZHVUdO
      TlkzaFVjM1l6Y1RCWVREYzFNbTlxU1U5Q2F6aDRVVVFyUkdWS1dHMVZhRkZwYWs1VldWTmxVRlZy
      YVhwbFlURm9hQXBOU2pjMGIybEVVVEUyTmpSWVJscHFlRXBqVW1aR09FTmxTM000TDJkTUx5dG5a
      a2c1ZDFCR2RYVnlOVkp5UlRWVFVEbFNlbGRrZVdOSGEwcDFXRFI0Q2xVck1UWlpTaXRJY0RCemNX
      TXhhR3R4YTFKTlNVdzJjRFJYTm5OMlN6Rm1NWEY0VEc5NVRrUjRkM2MyY1ZOUFUyWlpRa001VGtV
      eE9ISnpObUZMYVdvS1IycEdlakU1TkZCdlZrRkNjRGRSZFVJeU1URjJXRzlGYjBGNFUwUmtaRFUz
      WjFrNVJVcEZObGhtT1ZFeVRsRmhUMUE1T1VaT2J6UTVjakZuT0ZkUWFRcFdWMWQwUlVoeE5tRlRT
      V3RUUWpkcVZ6ZzNaRU5pVTFreFdqTlhObXA2WWxsb1NUSkRRelpHUkhGSlp6QXlPRFF3YjA5WE5r
      TTVTR1J0T0d4dkx6SkxDa3hJVVZGbFdVcE1Oa1I1ZDA1cFozWXpRVTVOYTBGcFNucElSMFV5V0c1
      RE0zQkxRMVEwU2xoaFZrTTJXV2xMUVVGb2JGRTJSWGxWUlhVMGJWWjBiMDhLTXk5M2NFY3ZSbEI1
      VVVwS1QyZGpXVnBtT1ZGV2JFcDBVMWd2ZEVjeVNWTmtVRmhpYURGTGRrWmliVlVyWjBsRlNWZHFj
      bU5qZVhKNWNpOUVVRlJwTmdwQmEzRkRaRlJuVlVVcldFNHdhV2w2YjNOdWQwTXlXV1U0VjJwT05W
      TjFTRTlMU1RCdGNHdzNNMk50WjJFd1YzcHNPRmhpZVU5V2NsaDZOa3d3WXpGQkNuSTJhWEJVUjJo
      dWRtZEpXWHBJTWt0TFdsWjJVV3BKUVdkdU16RmliRGs0YTBwdlJISjRkbWxtVGtOVlZuQjVkR1Zy
      TWtKTU5rWnBSbHB1YzNoeE5YZ0tOM0ZaWkdoS1pDOWhXRlp1S3pCSVJraE5LekpqYWtWcmVYSk9U
      RFZvWVVKR01WUjBjMGhySzBwelVFaDRZbmRPWlZSNk9YbHljMjQxVkdRd1RVbHpVZ28yVDJOUWRt
      eHBXa05ZWXowS1BTODVRek1LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit fremovexattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fremovexattr for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fremovexattr for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - fsetxattr
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_fsetxattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - fsetxattr
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80692-7
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030230
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_fsetxattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlZCZDFWQldWbExaemM0ZG5jMU9FUXJhalZ3VGtGUlowSTBVUzgwY21sVGVr
      SXhRMHROTVdzMmVFcHZheXRDY3pWak4yeEhUMVZaVTNrNGRXNEtORlZNU1ZGVmIweFJXbXBhVW0x
      TVoxTnBUWEIzWmtGcUx6aDVZVEJ2Ynprd1oyOVFXa3AyU2s4M1VuSTFkR1ZpWm5Gb2RGb3pUMHRY
      ZUhsUmVWSlhRZ3BCU21FcmNFWnpkMHg1VGs1MlpVeFpaa2M0VlZGSlpEaE9WM2RXTkVoRE5VVlFk
      RkpMZDI5MU5IcEhOV0puUzBoaFQzQm9jaloyWlVKa1Iwa3hkSFkzQ2pSR1MyTTVUMnhQYWpONGJt
      eHZWR0ZQVVd4SU5IcEdka0o2VUhSeVZFaE5jM1IwYXpCbmRqSTJhR1F3UlRKaFJtazRjbEJpYWxj
      MlMzSkZhWGRyVEhBS1UxUkpRbVZPV0ZGelRrdFJVMDU1VldOMVpFTTBabFpGVVRVNVpuTkRUbFJS
      U1hvMlVrVklLMmhaYTBsemNrcExORVpCVGpSMmRFaEdLMEZrVDJvell3cE5RekV4UTAxTlRXTnli
      V05KTlhKdFZXZG9OV0pHYm1kdWJTdEtWRWx2ZVd4WFJWRXdVMDlvUlV3MVp6UnJWVTQzYjJ0TmJ6
      bGFUVXhuYlU5RE4xUjBDamd3UVZKTWEwZHRMMUpaZEdOdmNVSjFaa3BYZGxWRmFXZzVWRzVEVGta
      b00yeEtXVWhFUW5sd1NERnFTMnN4YW5VNGEzbG5RalJuT0dRd2JWaFRhRWtLUjAwMFZHc3JVeloz
      ZG1ZdlVrUXpRMHBDTkc5bGFuWkJUbFI0ZHpRNFoyMVlNa0ZJWlhGcWEyc3pSbFZSZDIxRVEzTnVN
      M0Z6V1dGcVNETnNXRVF2U3dwSFprWnhUQ3RuYUhsa1JuWkZkVEF2VjJsV016RTBialZPVTNaaU5G
      SldRbUV5Um5ScWIxUlRSM2RySzJkRlJFWm9LemxRV0M5cFowNXFWbnB3ZERac0NubHNkWEphWmta
      bmFuUlpRVzUxVDJKYVdDOUNZVFpzU1hVeE9UUmtPVk4zV0VWclkwZGpVVVY0TVc4M1JXOUllV1pr
      Vlc4d1NITmpVa294VjNKekwxUUtlSE5QUzBvd1JTOUtlV2c1VW01TmQxZHZkRU51ZW1neVpWcHFX
      VzUxTTFBMFRWcEdaMWh3WVdkTFdEVkRLMWRJVGs5T1EyOXBkR0ZFVWs5VFNUQXlWQXBxY1d3elJs
      cFhTbFpuUFQwS1BUaEpRbWdLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit fsetxattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fsetxattr for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for fsetxattr for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - fsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of fsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - lchown
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lchown,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - lchown
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80693-5
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030500
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_lchown
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemM0ZG5jMU9FUXJhalZ3VGtGUmFtUkxRUzhyVG1WeWVH
      RklRVGN6V2tsRmRHMXVWazlPUkRFd1VFdEZlVlJ0UnpSWmVGQUtkMDl1TTJOWWFFSlBNRzFRUm5S
      Wkx6Qm9SMk4yYlhCMVNsSkNRV0pCYVZjeFUyVjZLMGcxYkdwaFdFNUtOekpvYlZObk5IbGlabVV2
      UkcxUGJFcGpSUW80ZERSTlJqQjFWbWxyYkRsTVRISkZjRGswVW10cWVGWldUMWhuYlVWM01WQk9N
      VEp6UVVocU1GSjVRMFZyTmpWcE9IVlNWM3BRVkVWSVVqZDZaa3hqQ2pFeVZFbEZPSFpoYTFBd1RG
      Tk9VekpWYW5kVVpIZFpkMk5PVFhrNFJrcFJPV3A1VTIxSlUyZHhVamxEZVdaQ05XVjJjR05XVFVa
      dlN6TXliVzVMWjBvS2JWUTVRVmRvZFZSdVRHeE5MM1JzYWtSUWNtcG5NRnBZVUhVdlJqSnFjazFK
      Y2xwd1JXOXlOWHBXWW5kVFdWQXZVRzFzWlROWU5VbHhla1J5UjIxSk13cGpkSGxtUzJwRGRXcGtO
      bVJpTkVGVkwyUndSMDVUTVhWemNYUnNUbXhYU1ZCdmQyd3JhSFZWWjJSSlpIRXpSbTV3Tlhoc1Iy
      SjRibmhVTjNkRWIyVk9DbEl3TTBwdUwzRkpRbHA0WTNSRGFWRnJZall3T0dsb2NIaHdhMmx4WkVa
      WlptcE9SMXBwZFdzNFRWZHhkakZZZDFVelMyeHhLMVJtZWxWaWFtSkNNazhLWVhKRVYyVk9kell3
      VHl0bWNrZ3dkMmxRUTNFeVRHWjFkRlpTT0hSVFkyMDBiM1ZQWW0xS1NTc3JNR3h5YjBrMlpGTTRV
      VzQ0YW5od1owaGpVV3hzVlFwbVRITndkR1J2U0ZGUFoxQnlWVEJRVmxoWVkwSmxlWFpvUTFkdGVF
      NUlNMnh1UzJnemIzWnJVRkJxZDBReU9XRm9lbFkxZDBkWFIzaGpaa2t6Y21oVUNrdFFTM1pVUlhC
      RmIwbFlNSFo2WkRsamJqVkxZa0pNY1VjMlQyWTBRV2R4UnpCVU4yOUxLMGs1V0ROTWJqWk9WWEpv
      T0c5RlJrNXpjV1ZrWldNMVdtSUtRelJIUlN0M2NtNXdUSGQ2Wm01Q1JUTnRaWGRMYkVwNU1URmtR
      emRIZHpsSk9TOWpjRVJPVkV4dk1HeDNMelkzVTFrMFdWVlNieXQwTWxoU1JGTkhPQXBFU2pGUWFG
      SmpPV1J4T0QwS1BXSTFTemdLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit lchown tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for lchown for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for lchown for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lchown
            syscall_grouping:
              - chown
              - fchown
              - fchownat
              - lchown

        - name: Check existence of lchown in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - lremovexattr
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lremovexattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - lremovexattr
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80694-3
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030200
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_lremovexattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemhOZG5jMU9FUXJhalZ3VGtGUmFrWkdkeThyVDBwdGNW
      SllOR2xPTUZGblEwdFpSa2xIVkRKVE16QkVhSGsxU0hWWWNIRUtSa2x0UjJONFJUTnlabFpMUjB0
      c1NrVXhWMUZsWVZaVVNqQmtNR1J3WkRWc2NtczROMDVsWmpRd09UTnZZVzlVZWxWMU1FZFhRV3hT
      YzFOb2FVaDNWUXB0TkZrd1prdDRZbWxGWVhCakwwNWtjMGc1VHlzM1NGVXdiMloyTUhCVlFVeFpW
      VVl3TWxOVVQyZ3pWRUZuWTBkTk1EQjNlQ3RIZVdGU1pHdFVNRzVqQ21oU0sySm5SMjFDZW05VVN6
      RkNUR2hWU3lzMU4zaDZZVmRWZWtaMWEyUTBZM3BaVGtGb2Qyb3pXVlp5UWtKa2NsWnFWRlU1TTNG
      cFEzRlZlVXdyY1U4S2QxaDBZMkptZWxKelJVd3pkRzE0TTNKbFdYRm5hbFJ3UjFGM05WUlNSRWQw
      UWpOTVYyb3pUUzlVUmtwNU5UUjNlbEJDUzNnNVIzWkdUM05KZVhWd1pncDNTREpOY0RZNE0zaDJU
      akJEUmxGb2R6RTJkM1ZQTHk4d1F6VkRWbEpWUkhSVWR6Sm5Va1V5UlRsbFpWZG1SbWRuVFZaTFdE
      bHpjMG8wVXpGUFVtOTJDbkU0VlhGdFZGUklPVVZ1TmpORWVXUTNlRUkyZEVvMVEwaEZXVE5hT1c5
      WGMwTktjakZTZG1WRWRteHJORXRNTnk5TWFrOTJabkl4VXpSeE5XVjBPVGdLYTIxRVJHZHNiV05H
      VldSdFJqRnplV2xXVG5SUFUzRTVUbms1ZVc5MVdWQndZeXRqUmtOVmFsUm5XV0ZpWjI1MWRGbGtk
      Rmc0Um1WMFVqTjVkMVJsTmdwUk0yZDJTVzFIU1ZsVWFHOVJXREJvYm5CRE1HRjRlWFpsVFRFMFJt
      Sk9RVVU0ZEhoMFlYcFVPWHBJZWtkaU16a3dia3REYzFWTlNFMXZibTF4Um5GYUNsWllRazUxTW5S
      aFpVbEJWM1JKYzJaelZrOUhUVk5GVjJ4TVpFRnlTR3BVTUVZNFQyWlpOamRoZVRWcFp6TjFlVzFh
      YlZkWU5WWnplWEIyU1ZCV1NrUUtTa3MxVGtVNU0zVTRhaXR1VTFSdGVuaFpZVGhxSzBGaVlVdzVN
      VVJoSzNveFkyaGhkMlJ6WWpKekx6Qm9RMlpNUldveWEzcHNZM0ZYVjIxQlFXNU1Vd3AzTUc4M1Ew
      RTNPSGxVY3owS1BXVlVUR2dLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit lremovexattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for lremovexattr for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for lremovexattr for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lremovexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lremovexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - lsetxattr
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_lsetxattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - lsetxattr
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80695-0
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030220
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_lsetxattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemhOZG5jMU9FUXJhalZ3VGtGUmFVSktkeTh2WVVoUFNr
      ZHlVWEk0UjNJeE5tbzJZMDltYTFCQlZXMDNiM0UwWkRkdFRESUtOMWh0WmtVMFkxSm9jbk5qYm1z
      eVExUXliSEJMWTBGaFEwOVZNMnRrTVVWc1EzRkdibU5oVGxoUU5XWnlWVlJ0TVhOTFVrNXliVnAx
      VkV0MFMyWjRXZ3BCT1ROUFozSkJUbkJPZVVaUk9DczNMMUZDV1dKdUsyeEhObmRxYWt4cWMycFFi
      RFpZZWtKVFkwdEVWVzAzY0V4WFQzWlZNVzVUTWsxVWRUQjNNM2xtQ2tReVRuVnZiVFpMYUV4MFoy
      WnljMUF5YjFCalduRkZURzUyTmxGR1MweHhiMGx0VGs5WVdrVTVVa3RKWTJkWVRucHhXbEpDYkRV
      NUswUjNVV1J3ZVhvS1JsaDBZWGR4YW00clZuZHBRMWQxY0Uxb1JDOVRjMjVSTkc5TWJqUkNaV3hT
      TUdSTU9EVXZVMHh4YzBKVWRtaDVlVVpTZVRKaldIVjROMU5SUWtoaVpBbzJiWFJDTjFKT1NGbE1h
      bnBQYVhCbFdrWk1ZbVZtVVZkNWREUmpNa3RSZG5aRlIzRmlWVTVTVW5Wc1dVUnpSMUJKU2s1UU1T
      OU9TMmRJS3pSSmEwcFhDa3RhYkhkdFYycDRSbmxHUjFoM1UxaHZia3hWVFdSR2JrdHZNbXBhVFRW
      T1ExZDFjR1ZvTjBKNGVsWmlVVEJwVEV0SldXNTRia00zZWpsaFUyTlhZbWtLY0d4T1pVZ3Jla0pF
      Ym5OcU5XUlNNVmgyUVVrM056RXdNakp5Y0cxd00yNVdOelZXWlVsSlZuWkpOR1ZzV1dRcldIaHlO
      RFZDYmtJek5YSlliVk5VVVFwMU1uTXZPWFJGY1RSSVJYUTFjVmxoTDBnMlZUVnZiR3RUWVVKUGFr
      TTRWRXN4WVRKUmVVaE9OMUozTTNsS2VrWnhaMFpWTW5kUWIwWjBSbVphTm5CUkNqVnhVRU5tTUV0
      aGRsbEhOMHA1ZGxWRmJsbDFWVk5IVGs1bWFucHVRMjVGTkVoRVUzaEhWM0JCVDA0M016TmtVVlEx
      VlZZelNsVnpWSEZPZFVGM01VZ0tNVTFvVGpaQlpWZHpjVTU0VVdKSVVtWnhSM2RZYWxvek5qZzBa
      RkJqVjFKcmFrTTJaek40WlVGNFFXbEJUSEp4WTJObVZGVXZibkZ1VlUxWVptdDFXQXBxWkdveFZG
      TjNObGN6V1QwS1BXTjVMMUlLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit lsetxattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for lsetxattr for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for lsetxattr for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - lsetxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of lsetxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - removexattr
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_removexattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - removexattr
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80696-8
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030210
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_removexattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemhqZG5jMU9FUXJhalZ3VGtGUmFWbG9RUzhyVFhCaVFt
      ZDBaWFpNY1RoWk4wUXdiMGxQUzBwSE56QkJXRmhqUmpkelkyc0tlR2xEUkUxRlFsSlFhU3RVV0hj
      MGRYSTFNV0ZLWTJSRlZVSTFZVFZ1TkVaMFdVOUJla2x6WWpSYVlsWXdPRWhIVlhjclNHVjNWbVZq
      Wm5FNVVHTnNOd3ByWjFNM1VFdE5WM1ZFZHpCcU5WbEZXa2xNZVZad05YY3hRa2cwV0ZCYWNFUnla
      M0UzWkdFcmRWZEdNVTloYUdWSVprTlJibTFhWTFKSWNVcHNPR1p6Q2pGWlNVNUZlVWR4U0dKc1FV
      cHVjRlpaVEhwbU5FWk5NVXhqVlc5clZubE5RbTFRUkZkNGJHVkdUWGgwUnk5WWNGbHZjRnB3WlhV
      MU5HUlhRM1JIVUU4S1dtcEpUbFJOT0RKMVZqWk9hVXMwVlZjMVpuUmhkRnB0TDNobmFrSmxjMWQw
      UzJ4UWVIZE9XaTlFWkhkTVZHdHdjVUo2TDNVM00yWm9aWEowVjFkR05RcHRSVXhhZDB3ME0xQm9L
      elE1UTNoVGRuZHpObW96V1c1MlF5OHZWWGhUUkd4YU9GZHRaM055TW14MGVGcDBkM0ZVTjAwMVRu
      a3hhVVZOTVRRdkswMW1DbUpISzBOUGNqbExPRXBXT0dSWksyRlhXV3BqUmxsTVVIQTVSRXR6T1ZJ
      MlkyaE5WV1UzWkRrdldHRllRbE5SVmt0Q1dGTm1UbE5MTjFKMVVrODVTblVLTWxka1kwUlZTM1pM
      YW1KU2JqWnVhMFIzVFhNMVIxbE1UbGxCV0RCWk5WUlNZbkZVZG1sUGFWRnpMeTlKVVZkc2IzZHhj
      MVJoYWpSb05YWXZia05hZHdwYU5WTk5Xa3hLWjJ0eWVYRXlRakJDUTBWcWVsQnRVMkl6VlZsbWVt
      eE1NVEEyZUhwbmFWUktlVUZyUlU1cFlVNWhOVFEyVjFkS2FIUnVVRXRwZW1vMUNpOWxkRWh1UVZO
      WFYyTmFRbk5UU2sxRU1HWlRSM1ZGWTBGeVRqZE1SSGw0ZEdKeVFWUkVibVp4TXpSRFZsaGtSelF5
      YjIxTVNIQkRWREZuVVU1Q1ltNEtWRWx2VG5CTmJYRmFWMFZpZFhNNFoycDNPVTFRVERadmMwaElk
      VmhaUjFGMFZFeGhkelpVZDJaMlVsRXpabEpWVTNSSFJ6VlJkMDAyUjFsVWMwZHBXQXB5ZW5KeWRq
      QjVhbGNyWnowS1BXcGlhV1lLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit removexattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for removexattr for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for removexattr for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - removexattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of removexattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Discretionary Access Controls - setxattr
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_dac_modification_setxattr,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Discretionary Access Controls - setxattr
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80697-6
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030270
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_dac_modification_setxattr
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemh6ZG5jMU9FUXJhalZ3VGtGUmFuZFZRa0ZCYW01cE5t
      NVhaM0JLYzBWNVIzTkRabkJGTVRKYVFrUnpPSHBIY21vM2JEWUtUekEyYlhocldYSTJSVXRGV1ZG
      blRFTjBSRTlVV0dGVE1HdHpaMEo0UWxoV2VDOUdaRnBpV1dKaGNrZFpNV016U0ROd1kxbEpaMnMy
      TUhWa2NtNTNNQXB1WVRKVWJEQk1Lek5XTDFVM1RubERSVXRQYlZsaGNHODJTVXRDYW1kR0syZHFi
      V1F5YmpkbUwxUjZVa2RFSzNoRVMySkVabkJtVUhkWGRUbFlibXhuQ2t4SGFXUXlNbEY2YmpabU1t
      OUVSbkZEVGxsa1REZDFka3RYWldSWWNUTTRURTVvVkZVd1VrMTVOa052ZFdkVGRVSjVZMUJVUnpG
      TGIzcFFOREphTnpZS09URnBRMlZrVlhNMlNqSlFWbkpuTHpsMFJscENia1ZUY25GNmVETlZSVTFw
      UTNBMlVVcHFiR3gxY1ZJNGVWcEtlVXc0ZFhKV2RIVkNPWE56SzBORlZRbzVUbFJDZHpsR1JXUkVR
      bkZNWW5KWlZHRk5WVEJPZUc1dGRuaFpkMnhtVjFWRU1WTTNRMlpHU1VjdlYwaDBWVkY0T1Zoc1NV
      bHlaRzVZVWpkVVNucG9DblV5TTNVNFdUQkRkRmcxYVVwcGNYaFFTR2xVUjJwd055dG9TMDk0U2t4
      RWNVRjRVMjRyYml0bFQzcHFjbW96VUVVdmJFRm9XVzFsVURkRFMwNXVTak1LZENzeU9HaFhka3M0
      YTBneldVOVRaMkp6UTA5NFJXMTRValVyU205aE0zazVaMFUyV2k5QlRYZHdTbHBxYkZsaWJXVkxk
      MjlDU25oUlRXOXdialZZT1FvMFZtaGphWEZzTDNob1NqWkVVbmt4Ynk5VE1WSlNiemxHYlVGNlFs
      ZG5ia0p1WlZZM1EzWkNWRlZHVm5kWGRsWk9WVVI2Ym1JM0sxTTBVRGR2WkRSM0NuVkxhMEp2VkZO
      QmR6TjNOSFZYUnk5b05HUkpRblExTm01bU9IbG5UV3MzYmxSNk5WWm9SalpSUVdWcWFuQkhjRFI2
      U1ZCb1JuSklXR1EyWTJOM2JFb0tXSEppYzNCUGVDOWpUekpCYTNjemRXZGtXWFIyTVZOc0wwRnJW
      RlZETnpNck5UVkdSMDVIWTJkMWJsSlBVazFqZDFWS1psRnVjQ3ROVmxwNFlYSXJZUXBxZW5NMGEw
      VlNNVnBDY3owS1BUQk1kWEFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit setxattr tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for setxattr for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for setxattr for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - setxattr
            syscall_grouping:
              - fremovexattr
              - lremovexattr
              - removexattr
              - fsetxattr
              - lsetxattr
              - setxattr

        - name: Check existence of setxattr in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid=0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid=0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid=0 -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - rename
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rename,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - rename
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80703-2
    - DISA-STIG-RHEL-08-030361
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_file_deletion_events_rename
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemh6ZG5jMU9FUXJhalZ3VGtGUmFuUnZRUzh2VjA5cmFF
      d3dhUzlFUWtwdkwyTndjRlIyT0RoV1lraFZkVEkxTjNCR2Rtb0tVbGh3VW5WcVdYRnJWbFV3SzNk
      alFTOVpkMDgwV0NzcmVGaERWMk5XWnpsUU1tRlhNVTVEVEdkVE1VZElTM1pvUXpObE9WVnVVakJp
      YnpNMmF6Y3ZSQXBPWjFJdmFEQlllVlJwU1UwdlYzRmlia3BTVFRkVEsyODBVRXBMZUdwcGJsSnBl
      RzlEVG1Kc2JsUnNaWEJRWjFwblRHcFZWRGw1VVdSSVpWUjJkRm8wQ21GTlRFb3lkSGQzT1hablFV
      dGhVRGgwTlRkdlEyUk1PVEpHS3paMFVHZGtkREJoVVRsek1XUnRWM2huTTI1MlVqWkRSbTF2UTJk
      UU0xUjViMFpuY2pNS1dHeEZkelprYzNGcWFXSnBhVk5JY1VJMlRFd3piMXBYVjBKTmNXaDBlbFk1
      SzB0ME5GWnhja040U1haMVJGcHZkbTkyWWxGQmMyTXhTbG8zYVdWWFRBcFVMM2hqY0V4U1NtMXVW
      RFY2ZWpSRFJtOHpkVkZqUVZoSE4wVlhhWGMxTm01b1RsbHhTR3RCYkVaclNYb3pMM3BRVEZSNFlX
      NXBPRVJtVm1sUVZVVXdDakpWWTA0eVVEVnFiMFphWnpkSVFrZ3lPRVJoYW1OaVFsbE9UV0pQT0Vw
      d1YzSkpNMkUzU1hWdWNFODNRWFpJVnpSWU1EWmFZazVDU1c1ek9XOXNWRGtLVTJ3eFRrUjVRV0Zr
      ZERZeFEyZDNiV05pWXpGVWFYWjRMMEl3VkZGSlQycEpRVzQ1YkcxUFpFOWxVRlJIZUVKSldtSm1i
      SFpyYWtoM2JqaG1WSGwyTXdwcVdWTlRaMmw1TldGdlVFZENNRmRuUWt0UlF6VjBjSFZVTkU0NU9G
      TkRkVGxNTlVkWVVsSk1lbUZQVDFCMU1ucHpTbkpGTlV4RVFWYzJWWFpKUlcxTUNsVklVRkYyUWxs
      S1RUZFFXbnAxZUZaelYyMTRNRzVVU2tOaWQzSTFiMnM1VkRWTU5XZ3lRakp0V2pOWmJteEtiRk5E
      WmpVMkwzUmxXSG8wUlc4elNYSUtNbTlHZG1Sd1FuQm5ZM1YzUVRaSFZ6aExNVXh2TTFwVlFsZFRR
      amhoZEVadFVVY3pSbUpYWVVKR1dTdERhRXBaTVdkRWNqbHljMmh4UlROdlQyaFlSd3BXU1ZwR2Qw
      dFBiV1JoTkQwS1BUQnBWeklLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit rename tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for rename for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rename in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rename in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for rename for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rename in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rename
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rename in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - renameat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_renameat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - renameat
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80704-0
    - DISA-STIG-RHEL-08-030362
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_file_deletion_events_renameat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemc0ZG5jMU9FUXJhalZ3VGtGUmFuSm5RUzh2V1N0dFdH
      OXRjbEZCU1VZMmJHNHpUSFpMV1dSdlZsQXpXWFF4ZVVoUlNta0tSMnRpVVhoTmNYSlBXa1ZOU1Nz
      ME1qbEZhbGhtYW5CdGMzVTRLMmRNUzNSdVVHazFMM1Z5YzI1elRubG5Salp3Tm5Oa2VXczVOU3Rv
      VVZJMGFuVktjZ3BrU2s1alpIbEtOblZ3WWtKc1lUa3hOSE5QVkRkbFNtbExjRkZxYTFKU1JWTXpZ
      amxFU1ZCcU5EZzBTWFZZTm5OWmJGcGtUREp1Ym14Qk0yeHVhbnBuQ2trNFpEVktabGhQZVV4WGR5
      OUVjR2R0VVhKR1MzSlVVamcxZDFSbU4wbGxXbkpJWldSWlQzQkpPRzVyVGxWRE1qaGFRbmxJWldV
      NFREWlZNRVJMUlU4S1VubFNjVzlTVUU0d0sydHhVWEl2VUVOYVRVSTFSa3htTldOUlNVOW9VMjFE
      WjFsNGVERXhWbEpRU2xOT2VuUnFiM1Z3TlRkMFRWVkdabkppUzFWU053cHRiMFpOYTFkb1pXeFFi
      MnhxVVM4dlNIUlBTMVUxY1ZRMGVGbE5hM2RVYjJvM09VRnBkMXAyVVZCQk5Ia3ZMM2d6YVRsSmNW
      SkdjMEV6UmpKMlRIcFRDbk50YWtWM1EzUjVZaTl6Y1dWclExaE9VVzVFTm05YVluWnRRMWRXVVdW
      SWRXbE1WMHgzYUROMVNXTlZiV0ZpTlRkM1RTdEhVQ3R1VTBWUVZuazVVSGNLT0RNemJUbFlkMGhS
      ZDBKaFduWmpOazVzTUZoaFkyTk5ZM04zV0dwTGFETkpWVVpPWTJSTlZXeFpXRzVNVjJJNVF6aEdL
      MlpVY201dmVFeGlORUp4ZUFvNWMzVkRjMHc0WkhnMllVNURRa293Y1hwU1YxcEpRMGxNZEZkM1lq
      Vk9aazh6TjI5aFptZEdSVGRVU25oQ1lYUmFibWRzTVZGcWVXZFFlSEE0VW5kdUNtTjVjRloyUVU5
      d05XVnhXVE54WkVSMVQycE9jSHBQWms1NllXVlVUMmRQVVhKQ1V6Tk1NblJLTkhoeldFZDBSV3R3
      T1ZReGVVTlFUbWRJTW5SeFpUa0tVRlZoTWxWVlowOUpOMVZqT1ZvNVZtMUVaRFZXTWxWTWVrZ3lT
      VTUzZFhWeGFqbDZOM1ZHYmxWMWMyNVplWGxzYm5oYVYxcGFhbGxYY0VFNFpYaERlQXBGTDFCT2JV
      bDZXR2R3VVQwS1BYUkJVMWdLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit renameat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for renameat for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of renameat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of renameat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for renameat for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of renameat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - renameat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of renameat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - rmdir
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_rmdir,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - rmdir
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80705-7
    - DISA-STIG-RHEL-08-030363
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_file_deletion_events_rmdir
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemc0ZG5jMU9FUXJhalZ3VGtGUmFFeEVRa0ZCYkVOVWFW
      RkxVbXRoUVdsemFIUktObEJtTTBoeFFTOUhiVzVwV0hCRGRHUUtTelY0TkRaM1kyOTNWamRNWjFW
      WUwxUkZSeTh4WjFGalJERmlURmt3V21SWVExcEJZVmxTUkUxUFUyMUJhSFZ3Y0RjemQxRkxjSFJQ
      YlZveVRXVXdUZ3BTTjI5RFZsUllXbmRCTmxGbmNrRlBPVm81VG5SNUsyVjJLMlk1UVRWR09HTlRh
      R0ZZSzBsWVlTOXNLelkxVEdWeGNtOHliMmxDZW1kT1Z6QllaVXQ0Q25wRFFUTk5Wa2xwZGpaM1pG
      Tkpiak14TVhvMlRsbENLMWxqYm1wclVuSjZjRWRCT1hJclIwRmhRemhHVmxjeE1sbHhaV3BJUkdG
      UFZ6TjBjVXBhTWxrS2MzcHZlREpzT0dOelVWQkViWG96VDBKT1RuYzBORU5LTW1wR1ZXTXhkV2xK
      TWpoVVl6bEtiVmR6WTBkS1ZEVlBhVWxKVUN0V2EyNUpRa1puYUZSalp3cHJkek4xYzJKbU4ySlpT
      a1Z2VmxZMk0yaFlWblpSTld4MVZtOWhTVTlsZDNaeWVHMU1RVVZaZFhaalkxbHpjR3BoWW5Sd05Y
      RXZURkprVFV3NGEwOUNDakZCV2xJNVdqRXJSbFpNV1hwNGIyeEJTbWhVTURkeVNqbG9UV0YwV25G
      TFZIbFBTV294WjI1QlFWVjFjV3hLWlVWT2VsWlNMMjVLWkVaR0sybFVhMmNLZEVSclFtcEpVVUZU
      Y1RGblZqSjNSazVNUzJKWVVGZzRPWGg2UlhkdmRFRXlVVlJ1TTJjMk56VTRPVXc1VEVGbGFVNURN
      VVEzSzJ0dU5UZFRibFZtTndwU1F6TlhTRXBET0VKSmNraG5lRXB5V2pORFowODNNRmQxVEN0cFUz
      Sk1WRnA0V0hsdWNscG1halIxWTNObE4xRjNOMDlJTmxBNVlWUXJkazF5Vm5kNUNsRnlkM1pvVG5C
      cWNqaDBSbTl5VTIxbVZHOHpTMFZvT1Uxck1tRkdSMWhqTnk5SVpFUlphWEZQVFUxaldsUmxZamh2
      V1hkVVRISlJNRzlPZGsxS2FHVUtXSGd6VDBZMFREWlpVa2xFVFRkaWMwVmxjbGgzUldwT09FdEVS
      MjlEWldkUE9UbFBVbGNyVUdWUFoxaEhNVmxST1RNNGMzWnZOMmRySzI5a1RUZzVUUW8yV2tOM2NX
      bFRUV2d6VVQwS1BVSlpORVlLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit rmdir tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for rmdir for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rmdir
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rmdir in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rmdir
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rmdir in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for rmdir for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rmdir
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rmdir in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - rmdir
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of rmdir in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - unlinkat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlink,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - unlink
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80706-5
    - DISA-STIG-RHEL-08-030364
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_file_deletion_events_unlink
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlZCZDFWQldWbExaemxOZG5jMU9FUXJhalZ3VGtGUloxbEZkeTh6WlU5RUww
      eDNjRVZ6SzJwUE5HVk1UVGhoTTJKRWMyVlBZVEpzZGxkYVFWb0tlRVpLT1hreGNrMXRlR1JKWWtS
      a2VFTXhNbWxYWnprMU9FSjZXVVJXUnpkaVp6VmljRTh4VFdoaFZWYzJkMjkxV0RSVlZGQnliMDlR
      ZGpOTWJGcG5Td3B3WlZaa01YZEhOa3QxYzFCd01FNTZUek1yU3pJeVVXMXBOM3BOU1hKbFYyWllV
      amxYZGswMVQyVlROWGhZVDNOVU5VRXJXWEkxTWxwdGVsTmtWamRQQ2poNk1YZGFUM0ZIVVZsMlMw
      eFphbGQyYjFkbVJsTkdSM2MxVTNkRWJXWndTekU0VERselpUUXJjRGxuY1dWc2VHVlFlVlZ3UkZK
      UEx6UlRaMGxEUVVrS1lWUXllR2xNVjBWT2JUVklaVlJIVTI5UWNuRTFNVmQ2YVRGQll6TkxhRTlD
      Y1hKMU1tTkpWR2gwTjNWSGMwMU1OVlJ6VGtWU1EwOTVjVmhyVW1GMWJ3cHlkM3BQVTNKd2IxRk1O
      VlZQT0dseWJsZDBaVFJ3TVZSRFVIa3llV0ZoZUVOa01DOVJiemhpU1ZaWVZXWm1ZbTFLTDBaWGRp
      OUdRWFpKU2pkMmREUlhDbGwzYmxBclIwYzBNa1EzZVZjeVpIRlBhR2gxZUN0aGFtTXpWWFZCT1Vw
      VlRGWkJReXRtYlM5V2RqaFpObXB2TURoblFsaHhRMjR4V2t0cWMzWkhVRmtLWVdGdE9WZFJVM1pw
      V0M4Mk9XNHJlbVpUT1ZKb2VWVlNkekIxV1U5amFURkxLMDV0ZUhWWWN5dHhaakkyU1dKUmVtTkxh
      VkpLUzJ0TE9TOVNhRmhMUkFwbFIyUnRXbVExZUhwM1VHaG5kRUpaVVV0U05HdHpNVnBLVWt3eWRW
      VlhlVlZyVlhOMldHOTBhR0o2ZHpZMGVFWTBSRUl2VERKV2RsUmlNVFkzY1dONUNuaEhkV2xYV0Zs
      cVUyWmhXR2RSZEVGb1RHUkxRa3BuV21KblNVRmpPVlpZZFU4eFEzaDJObkEyYTJwd2RHWnJWU3RO
      YXl0YWRHbEViazVaU1dSeFZtWUtOVTlVWW05RGJsTnJaVGxoVUZwVFpVRnJNRFZ6ZFdKeVpUQmtV
      azl1Y0VGUU9EbGFNR2RwTUVjNU0zVjVjVGRCVTJOWEsyZHRaek54VjFSUWVrNTJaUXAyTm14SE5r
      WmthMFpuUFQwS1BXVjZWelVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit unlink tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for unlink for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlink in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlink in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for unlink for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlink in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlink
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlink in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Ensure auditd Collects File Deletion Events by User - unlinkat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_file_deletion_events_unlinkat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects File Deletion Events by User - unlinkat
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80707-3
    - DISA-STIG-RHEL-08-030365
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_file_deletion_events_unlinkat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemxqZG5jMU9FUXJhalZ3VGtGUmFtNURlRUZCYm1kT2Ez
      TklXVlpRWkZOTE1YZFplRm8yZEZaVVZHMXJOMm8wVGl0b09FVUtTbWRuY25CSmVEZFViSEJRU1RZ
      Mk1FcFZlR1Y0TldFek0xazRTazlsVVZwSWVsVlNlR05OTlU5R1NVSkdVRFJLVTFabWFFNWFOemgy
      UXpreVQzVmFSZ3BGUlVGSFdXOUtia1JWUlM4MVNqWmllVWxrTVZZdlF6SXlhazlVWkVKSlJXNHZS
      R2xTY0cxbGFYaGFiV2cxTWtKUVVFMVdVSEpHWVV0NmRUUlRXbXRZQ2k5VVVqQldjVzFHT1RjM2JE
      WnJXWGhaVXpBM01XTmtOVkptTHpZd2JURTBVbmxaZEZkU2QzSnpRVXhNTXpSSGNITjNXbWx3Tmts
      MFpEQXphalJoWVRNS1NEQnhXRFl5VmtjNFlVbDBlVFZMVDNaMldGcGtVVkkyUjFKRlpHcEljbTFU
      ZERkUFpHVkRURlI1VEZSblkyazRNVWw0U1VoeWRuWmtkbXByWlVsSWF3bzRka1ZMV25sdVlYSmxT
      MEpZYTBoQ0wxWnFTWHBVTDJWRFpFa3hlVmRwVG1oeE1qWlhOVEZxWWxKbGRrNXRObVV3UWtocFNH
      VkhRbU4zWVdZeFdEaHlDbm80YUdkMmVuVjNZM2d6TTJneVdVMURWRTFNYms1R1NsRlpiMGswVFN0
      alNHbHVjbXhqYzJoSGJFSlFSbGhtVWk4cmFYWldhMHRUVHpNM1lrZG5WbGNLVDBwdWMyUlNZblo2
      V1hsNFIyUlJkRUZUVURaelUzRjRUMlV4YmxCUk5VUmhTMnRDTDA5VVpDc3lUMnhXTVhGa1pEaHlj
      M0Z3Y0dRcldXSmlibTFUWndwWVEzVm1Ra0ZhUmtOemVFbzVRV0Z5T1VObVpIaENia3R0ZGpKR1oz
      WkphRmhhZUhoSVRUVkRNMFp4V0Rsb2RsSktZbG96ZVhCdGFWSXpVSE50ZDFoRkNrcDRjV2R6ZVUw
      elRsbG9RMEY2UTNaSlpHZDJPVk5RTm5CbmJpc3JlRTVUVXpWak1XOWlkVkZLTTJwSlFVeFpha1J0
      UmtwTU0yVkZkMEpRTVVGTlFXVUtSamhDZG1wcWNGVmFhVW81TTFsbVFuVjZaemN5ZFZwVmFuVmhi
      MFl6Y0ZJM1dtWmxRVVpIYTFaRVFqaElRbFZCUlZKSWEwcE9ObVY1TVN0YU9VNVZhd281ZGxZMmRF
      Rm5UMGcyV1QwS1BVUTRWSElLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit unlinkat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for unlinkat for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for unlinkat for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/delete.rules
          set_fact: audit_file="/etc/audit/rules.d/delete.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - unlinkat
            syscall_grouping:
              - unlink
              - unlinkat
              - rename
              - renameat
              - rmdir

        - name: Check existence of unlinkat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=delete
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Make the auditd Configuration Immutable
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_immutable,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Make the auditd Configuration Immutable
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80708-1
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030121
    - NIST-800-171-3.3.1
    - NIST-800-171-3.4.3
    - NIST-800-53-AC-6(9)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.2
    - audit_rules_immutable
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemxqZG5jMU9FUXJhalZ3VGtGUlozSmtkeTh2VWxWMlZW
      TlBjM1ZoTlc5alFYcFFRWE5PYW1aaFFsUm9kMGxaWW5scmFVWUtObWxQU1RGYVZ6QTJiV05DUkRC
      S1MzaHJUVlJuUmxOYVNucDFNMFJOYUZoNE5rSmFTbmM0UlV0R1dVWXZNVEJ2TXpOTldFa3JOSEY0
      Y1N0SlNXVkdSUW9yVTFCclJXOWtTVGxOYjFSdVYwZ3hNVWt2TVdscFJESm1kWHB2ZDIxWWVtdFJP
      Vmx4T1d0elMzSlJhbWt4VG1abFJXUkpaVkJ3YTJwbU1sVlRkMEZDQ2t0SWVWVmpUMHhTWTJFMVYw
      SndWbVJNZFd4MU9EQXhia0Y0VFhjcmEyWjFVR1IwZUZCRE9VaEhVWFJ5Um5CVVkyMVBZVFpCWjFa
      UVZrcDZSVUo2TW13S1ZXeGtaazU1T1VGcE5WcHFXVlpwWlZkVldUQkJRMjE0VkRFNVEyd3dPVlJZ
      TmpSamRFbE1USFZ5TDJZeVYyUTBVVkJ5YW1FMVVVeGthaTkxZDB3clRRbzFMM0p1V0ZGelFscDZO
      VVpRZW5WUmFIbEdlbk0zWkU5QllVeDZhMHBuVGxGWlIzZzBjM2RsTnpWd2VFNXpOWEkxWml0blRF
      WnhhRWRXZG1nMFlTOWtDa0pLTlZKd1NucFFlV2h2WkdVd2NVcFBPVGx6VVVNelZrUmxaR3cyUkU4
      ck5TOTFZV3RtUjA1RlkwMDVlR2xtVUhsc01YbGFaQzkyYldkcWNtOVNWRElLY201NFVYWXhVV3cw
      Y2xSM1MwcFJlamt2VGtZck1VcHROMHRzYUZNeFEzVkpjM0Z0V0NzMFNHbFROelJQZUhSTk1HbFdk
      SFJzZGxCSFpWWnRVbnBGZVFwalVVRkdTVWszYnpoWFN6aDJRbFZKTDFCd1F6WXhSU3REZFRGMmNu
      UXpSa2wyWlZkNFIwSXhkSEZRUkROeWNVRlRaVzlPZEZnMVZWbG1WakY2TDFKdUNtVnNVWGhVU1ZK
      MFQxVnJaMnBXUXl0MVdUbDVNSGc1U1daSU5FWjZTbkpsZWxSUVJVUjRNRmQxVmpSdFRERkViRTk0
      UTNKUE1XRTRZVEJKWVRJeGNVZ0tORlJEUzJSVU0yRTVhR1poYVRGSFRHUlRTWGt2Ukd3dllrOVVO
      RGR2ZWtNelVrSTVaWGQ2WVVWc1RVTkdlbEYyYm1zcllWWTVhV1ZpTUhWMVNVdFNkZ3BGUlN0c05s
      TkhjMHBIVlQwS1BWUkxja2tLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Collect all files from /etc/audit/rules.d with .rules extension
      find:
        paths: /etc/audit/rules.d/
        patterns: '*.rules'
      register: find_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Remove the -e option from all Audit config files
      lineinfile:
        path: '{{ item }}'
        regexp: ^\s*(?:-e)\s+.*$
        state: absent
      loop: '{{ find_rules_d.files | map(attribute=''path'') | list + [''/etc/audit/audit.rules''] }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add Audit -e option into /etc/audit/rules.d/immutable.rules and /etc/audit/audit.rules
      lineinfile:
        path: '{{ item }}'
        create: true
        line: -e 2
        mode: o-rwx
      loop:
        - /etc/audit/audit.rules
        - /etc/audit/rules.d/immutable.rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Ensure auditd Collects Information on Kernel Module Unloading - delete_module
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_delete,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_ol
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Unloading - delete_module
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80711-5
    - DISA-STIG-RHEL-08-030390
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_kernel_module_loading_delete
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemxqZG5jMU9FUXJhalZ3VGtGUmFuQTRVUzhyVUdZelFp
      OXpVQzlHY0ZGeFkzRXhNelJSVDB0b1NscHVhekpUVjB0QmRFMEtjVWQ0ZVc1NVdrdDVVekY2UjFn
      MFVVcElTRmxoYjNkaVpEZGFjM3BKVG1SeFNHVkpNa3BCZDJJdlVFcFlaVzh4T0RZclYzWkdTRXQ0
      VnpVMVYySjBSQXB5S3poblZYSm5XR2RTT1hKNWRqUnlabkpZUWpCRFRERnRiRXR1VkRoWlJXMWti
      blZuVm5wTldDOTJaRXBuVDBoNE56QXdhSFpsY0RsWGNrNUljU3RYQ2t0aUt5OURZbG96TkU5WVNY
      UmtablJVU213MWQzcGxZMU5YUnpKQmJISjZiMlZTUWs5bmRWTldkWFpyVWxWdE5FODNZV1p4UW1a
      SWEwb3pMMU42Y2pnS2FuVkZLMG8xWTFOT2NVdFlkSHBuWmxWV09HWlVWaXRoUVVSNmNGQkRNa3BM
      UXpOMlVUSnVRa2RFYVVKS1duQnFLMjluWnpCeVFYaHdabmg2ZEdGb2VnbzJWMWR3V1VSNFlYSTJM
      elpFUkhWRGRHOUlkbUZGTDFoSFV6VlJhM2RhYkRnek5UZHNPRXBHUVROT0wwc3dWMmxtZWtrMGRY
      aEdVemxuU1dkV2IzaEhDbFUxVFRKcFFVbDRkVzUzVDI4dmRXSndlRE5CVEZaRldIZFNXRlI1ZDNw
      RmRVRkVjRE5UTkZWaWFpOVJNbUpIZGtadVoyaERLM0l5Y0dWQlJHcE9OekFLYlhsUlRubHpNRzlW
      VmpSeVQxaHZUSFYyUVRsSVFpOXFWRGx0TkVkb1NVUnRja2RGT0UxSmFsRnZiMHBKVFZWR1prWlFS
      a1pHU25aNmEyNU9WaXMwY3dweVRIVmpia05IZUZwMFF6bENNVk5TWTJ4SlYyOU1XVFpIY2psRlYx
      bHpaWEJVWjIxUlQwSkVZV2s0YldGUFFYaElZWGh5YUZCclNVdHNNakJITUdKekNtRjNPVEZIV1RF
      eE9XOWlURmd4Y2sxRFptMUpXbE4zTkdSelptOXFSV1ZGWWxaaVJ6UjFTM0ZaV1cxR00yNVRURmht
      UVN0SFJIUm1hM0ZRZFZOQ2QwOEtUVUZ4VVZST2JXSXpMMHB0VDJoS2RUQjJlbGxDYVhWa1QwcEpj
      VzFVVWtRcldtWm1jV2hoYkVoUlJHZGFabGh6ZEZCUmFpOVJTMHBwWVZoRWRtTjZjd3BKY1dOeU1V
      bEhhMEpUUVQwS1BYRjFTMElLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit delete_module tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for delete_module for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for delete_module for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - delete_module
            syscall_grouping: []

        - name: Check existence of delete_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_finit,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80712-3
    - DISA-STIG-RHEL-08-030380
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_kernel_module_loading_finit
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaemx6ZG5jMU9FUXJhalZ3VGtGUmFrMVJkeTh2Wlc5elQy
      aEtXbEJGY21abU5VTXhhamx2VG5WUlRHbERWVVpKTld4SlEzVUtlbVJIVGtwamNTdGtRbE55TDNO
      eFJVMW9abU42VERaRVJ6TlNkWEpKYlVOWFp6Vk1VMFJxZGs5SVZFNWxOemR6VUdONGRUazViM0ZV
      VGpGbVJteFBRUXBwUVZjNGQxbHJVMEZzWldWUFpISm1UMmxwT0VoSmVXUldOa05hVDFOalRXUkxa
      bmRSZEhnNGJYVlNlVWd4UzBsTlZXTkJTemhQWTBkSWVuVTNTbE5hQ2xsb05HaHZTV04yYzNkc1Qw
      TlFaVGQ0YW1oaGRHbHFaWGd3ZFVORFRVaHFiWFpZU1ZKRlUxVlFWM2xUWlZsMVdqaFZhSFpvZVdw
      UVQxSXZSRXQ2U0ZrS1JqSnVLMnhOZDFKRFMwNUhjbXhJVFhWYVVsQlBNamM0ZDFOT1ltNTJTemRw
      Tm1WMGR5OUZTR1JIYkRKT1JsUTRjMFpPYWt4cVNUTlpZbUZLYm5ORWRncE1ibEJFSzFoU05WQkhN
      V3hZZVc1dU9IUlpMelZLU1ZKS04yWmtiVko1V0hwR09TODFMMWhSZFhaRmMwZFFPR2RNYlZKUmMy
      bE9WakEyZEc1S1NWcGxDbGhJV1VsdGJWTkhNRVpCVFRabEwyMXRSa0oyYlRKVFdqTndaRkZYVjNS
      R2FWRkxLM3BrUVZVMmVraGpjemhXYWl0YVZFdFdlVmxoUjFsWGFHZEJaRWNLVGtOVFNWSTRSbFk0
      WlVkd2VHUnNSRzVHVFRWaVdVUkZPRUV2VjNSU2J5OU9jR2hoZVU1MllWQk9OakkyUm5ObFJtSjNl
      SEpSVjB4dWNXSlBNMFZEZUFvd1NtVTBTazQ1T0cxNVZtVlljbEJ2SzBwSFN5ODJiV0ZrYlRNcllV
      WnRVVXRrVWtKNFVrbDJOR05VUzNSWFZGRjVWWEJvU21NMWF6QnlXRzF3UWk5eUNrVXJRV2xMV0da
      UmVYUmxaR3R2UlUxdE1ISTNRVmM1WTBGQlpYbDZhMWRDUTBJd1NrRXlaQ3RXT0U0dkwzbExOa0ZJ
      UkZVdmRDODJSelJwVmtsMU16TUtlaXMzYjFodGQxUmhiMGRXVFN0T05FTlRSRVZOTDFodlpYWjFl
      Uzl2UkVGUmFVUlVZMW8wUjNaUFRrVlFSbTVaTWxZM01YTk9UUzlGVm5kSWVpOU5NUW8zVHk5eWEw
      ZHZkV1pxVVQwS1BWcEdaQ3NLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit finit_module tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for finit_module for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for finit_module for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - finit_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of finit_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Ensure auditd Collects Information on Kernel Module Loading - init_module
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_kernel_module_loading_init,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_rhv,multi_platform_sle,multi_platform_ol
# reboot = false
# complexity = low
# disruption = low
# strategy = configure
- name: Ensure auditd Collects Information on Kernel Module Loading - init_module
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80713-1
    - DISA-STIG-RHEL-08-030360
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_kernel_module_loading_init
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaems0ZG5jMU9FUXJhalZ3VGtGUloxQlhRUzh2V21waVdU
      WXdNRFkxWjJ3NFRVWXZOV0U0ZEU5R1YwSnFZMFZyWW5veFZqQUtWVzFYYzNNNU1FOHdVa1JCTWk5
      V1QzWnJNSGd2V25SRVFrZEtURE01YUZrMWNrazRSM2hxVUUxSlZrOXZaR3RDZUdwS1owRnRlSEpG
      YWtWWWF6WnRTUW95VFcxV2NsQlVjVkV6YVVwbE5WUTRhR1JxUTJRelJIUlViV2xLUnpOMWJXdDRl
      REpxTlVwcE5XbFhjR2g1U3psWFIybGpjVXBEZGtGVWVHeHZlRm92Q2lzNVFqSnJUMlkyVVZReldu
      aHhlazFOV1VGUFJDdFpaR2haY2tnME1XbDVPRk0yTHpBd1JITjRhR3hWVW5GSGFtTjRSVzQ0YUVW
      dFNHaDZNMmRSYVdVS1NIUk5SM3BwUWtOV1lpOUpibmcwVEZGTE0zcGlZMmxuZUd0SGJuSlFNVlY2
      UmxaTlZtVllUV3hyZUhkVGMzbDJTMFptWkd0NE56Tk9RVlpTY0hZNGJBcElORVJGVUZnMFkyNUZN
      RXd6TnpWdk9UUkJZV1p2WVZSNFVUVktWVWhWWVdOQ1ZHWm1UMm94WTNGR1VUaHVVVUZhZDFCcFpV
      d3ZUM2RwVURCVVpscGFDa001Y2toM2VVMUNjRlV5Wm1kMlIzaHRjSEJTTjBNMVdsTklXa0ZyTlZw
      MWRtSkxhRmt3ZERCUWRsa3JRM2s0TUdWd2VVNHpTVVZVYW5KTVFrdzFRMmdLYVdKUlpFNUdObE15
      VDJVM2JITkNla1pSZFRCT2RXOUdWbVZzVGxSYVJEVTVUVTFsTWtaU1UyczBZakI0YzFOck9IcFVk
      MFpOWlRJNE5rVjFiamxJVGdwR1lrRldaUzlsTldJMmNXOW1ibGRoVTJRM1drWlBVRUp0ZEUxSFlV
      UkJVMmRSZEVGT1VIcHlTMUl2YjBVMFVXRm9WSGgzTkVkU1ExVjVLMlpFWkZBeENtSXdPV2Q0TVZG
      YU9TdHlkVlpPVWxaMFozZElSblZxVWs5SGRGWlVSMGhOVUROV1RGZExlR0Y1WVZoMFptNXhSbk54
      VTJOWFdHNUhhMW80TVhKWlVHVUtSV0YyZDFOUFNHSkpWMnh3WkRSa1RXdDVjRUkxUnpSVWNEUnpk
      M2w1V2tkaWNFOXNlSGtyVVVRd2IweFdkVlJHTURGRU55OHpWWEJtZGxBck9HSTBaZ3A0T1RsaEwz
      TlBjblJIWnowS1BYQmhZMGdLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit init_module tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for init_module for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for init_module for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/module-change.rules
          set_fact: audit_file="/etc/audit/rules.d/module-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - init_module
            syscall_grouping:
              - init_module
              - finit_module

        - name: Check existence of init_module in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=module-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Mandatory Access Controls
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_mac_modification,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Mandatory Access Controls
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80721-4
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.8
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_mac_modification
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaems0ZG5jMU9FUXJhalZ3VGtGUloyeHhkeTh2VjNsNlVH
      bzNRa2w0TTBWQmNtTjVia05GVVVWeGNWbFBlRXBLZGtSS1oza0tZMXBUZUVaSlptcEpZM0ZrY2xS
      TE5IWnphVEpOTkZBd1FtbEpRbXBKUWtSREwzbHlTMUZ2ZVhwMGMxSm9lbkpwYUZoYWFHc3pSMHhD
      Y0ZWWVFXbHFaUXByVEd4d05XdENPSEJNTDFCUVFuZEpjVFE1WVZwb2NtMUVZamRNTmxONmJXUTFV
      VVpLV0ZWM2VqRnRUVWhZVVN0VWJtSm9NMUo1UWpGT1dGbzRNMFJJQ2pSdGRGWkdUVW8zYUd4d01X
      RkZOM054YlVoSVNubFNaMjB4YVRCb2FHZFRlVEJ5ZWxjMkwzRnhTR2RPYW5kclNYSmFkWEJWVmxo
      aVNFNXRaakpOV1VVS1dXUTJkbUl4ZUhGc1JWTjVlVmRFWmpoeFFXeDVVM2N3YzJWMVZYbzNabE5v
      TlZnMFlVUldlVmxFUkVocVYyUkpZM0p1Um5JMFowZ3dVVkZFYUdwYVJRb3pUM1EyVVdReEwzaFZj
      SEYwWVc1a1ozSmlaREZqYzJkTmRXVlRkekF3ZEVWTFdpOWhXSEV6VXpOdFRWQXhTVmNyUm1WVVNG
      ZEtWME41YjFZeWQyMXZDa0ozYTFaeFZ6WXhTV3BQU3poU2MxcDNUV2xYYkdsTFZYbG9TbEJtUkho
      VVN6QnZUMnBIUldSUk0zcFhjRFE0YWtwSWMwaGtSWGt6TTJWU1RXRmtOa2dLYmpWTFdHRlpTak53
      U0doV1ZXdHNURWRCTDJoUWIzbG9aVUZSTDJwSmRuUTVlVnBVT0RGRVZHRlJSa2QzWTBwclEySnJa
      WE5aUjBobE9XODNTRFI1VmdwMlR6Uk5VU3R3U3pWRVZESjZVVFZ0VjFaME9VOURXazlMYlRScmRI
      WTJkbU50WVhONE9XbDFRVVZGSzB4cVRpdG9jMmR5ZDFVeVZFOTFVWGRKV0ZkWkNrNXVZVlpKU1ZG
      RWJYUXpla2NyUjNGMFdrNVhXbEpVTVU5cFVuQmtNR0pVYlhOeU1TOHJkRGR4YlhGR1JFbHZOM2x5
      Y2pOT1RsbDJjRkZQTWsxT1pUUUtTbVJGZUZWcFpGWmlURVZtUWpWWGFUaG5hRWRaUlZVNGFVWlZi
      R3RwVDJkcGNuZG5lREl3TjNCR1lXOXpjVWQwVkhGV2VuSkZkbnBRT0V4TFpsSjRLd28yVVd0R2NF
      WklNWGMzUVQwS1BVSm1aRVVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Check if watch rule for /etc/selinux/ already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/selinux/\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key MAC-policy
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)MAC-policy$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/MAC-policy.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/MAC-policy.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /etc/selinux/ in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/selinux/ -p wa -k MAC-policy
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /etc/selinux/ already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/selinux/\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /etc/selinux/ in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/selinux/ -p wa -k MAC-policy
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Ensure auditd Collects Information on Exporting to Media (successful)
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_media_export,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects Information on Exporting to Media (successful)
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80722-2
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030302
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.7
    - audit_rules_media_export
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaems0ZG5jMU9FUXJhalZ3VGtGUlozbGtkeTh2WmxwVVR5
      OVNhbFZvUlhKbE1WWlNWM2d4U0ZGUk1tWnRUMDVZT0U1SGVHSUtRbTFKVWpJM1ZGbFFkQ3Q0VjJs
      cFIwdHlTR3hOUzFwMWFXdE1jRGhXTVRSM1FUUkRlWHBJYjJsVFUyOVFkMWhITlc1YVUzVnVUV3BW
      WmtaeWJFWmFTd3B1ZFZWaGNHTlJUVEZuTW1KQlNsUk5kMlF5VkZwcWNIQk1VV1pNVEZaRGFISkNT
      bGhhWTBsaVNGVllSVWhQTDJaSVlVWTJVa1owY1ZsQk5XY3lVM0JKQ2tOS1QyTm9NMEkzVGpKdldp
      dG5aalpuY2poQmJFSlBVRlY2UzFwM1NIQTFaVzE0TVVKdVRVVm9TMHdyV2t0VVNGVjNUblpyWTNS
      NVpGbHdUUzgzUlVVS2J6SlZRVEJ0Ykd4a2JFdFdRMDVsVWtFMVVUaFJhV1Y1Y2pWdVlUTjJNMGxG
      TDJsdE5YbGtaRkphVFVveVZuQlRWM3B6TkV3eU5qQnFRazFyZFZsT2VBbzJjazh5TkRkMlJsWlZj
      SEowTjJOS2NrVnJhVUZVT1hkMlR6SmFVblZMV0hwcFFUTkNTMWQyZDJSVGFtTk1Ua2R3UW01eGRE
      aERWMkpzWTBjMlVIbG5DbXB4T0ZwS1FVRXljVGxhV0hWa2RISjFlbVpyUkVKQ1JuZzJWbkZ0TVdk
      VVZrSTRaVEJoU2sxclZIVjBVVk00V2tneUswcGFRamxvTkcxbE9EY3ZhMjBLV2pWNWFtYzVZMlox
      Y3pSbFFqVnBSV2Q1YmtsblNEUkViV2NyZFdGMlRHbGpRVE5sVFVsVk4ySlhNbmRTYVRsMFRUQlJh
      Mmc0YzJaamFVNWxSR2xPZEFvdlVIbHRObnBtZERkQlptdE5MMmRPYUdKYWRubG9iVTh5YkhOU00y
      NUxWVlk0UzFCcWRVczFOMEpQZHpReGRsSm5VRVpFSzJrMVlVdEJLMUZNTjBsU0NsbzRkazU0V2pC
      cFdqSkRRMHRwYkhabldsSTBWM2xTTVdNcmVuUlBUbXA0VDAxQmFXMVJlVTVyY1N0UmIwVlBkbTVU
      V0ZkWlJGcFJaVUpJUWxoelRIRUtUa1ZsVlVsa2RFb3JjMGd3WmtWNldGVjRkMFpOWlVkVWVHbG9a
      RTg0YjBNMWVXSlZjazVNVkdwRFpGTndiREJLYVVzMFEwczBTa3h0VHpsb2VEVjBhUW80TjJ4RlJW
      ZERiVXh5UVQwS1BTODBMM2NLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit mount tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for mount for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for mount for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/perm_mod.rules
          set_fact: audit_file="/etc/audit/rules.d/perm_mod.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - mount
            syscall_grouping: []

        - name: Check existence of mount in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F auid>=1000 -F auid!=unset -F key=perm_mod
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify the System&#39;s Network Environment
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_networkconfig_modification,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify the System's Network Environment
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80723-0
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.5.5
    - audit_rules_networkconfig_modification
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXROZG5jMU9FUXJhalZ3VGtGUmFVUnZaeTh2V0RkREwz
      VkhPVnBZU1dkQ05YSXJOSG92YUc5SWNHZGxiRkJVZFZkSFQyb0taREo2TldNNU1TOVhhR2xrU0dW
      TU1IcDJZMk5hZFhGT1YybEhaVk5STjA5UmNHWTVVVEEzWjIxNk9WUjVWVzEwYld0cGJuUlplVVJz
      Y1VWRVltOUNRZ3BhVEhVM1dXSm1hMnM1Wm10a1NHZERiSGxZY2xsaU5XMW9MMGxZYzJ0RWIzSnNW
      MmhNYXk4dlRFVlRVMWMzVVdKSmVHaDFlalpPT0VreWVraFNaV0oxQ25OTEwwbDJOVlo0U1ZONFNt
      VlJkVnByZURkR1pYZFZUMklyZUZoRGVGRk9lWEZLUXpaVFkyWmhja2swWlVnMmIyWklWVmxQZG1G
      eFdHWjJRMlp4TlVRS1R5dFViR1V5ZDFsU05rOHhlRlZOVjAxeFZWaHBNbTl1SzI4dmNIVktiMjR5
      Vm14dmJtUkRXWHBGYm05UVZ6YzVVMVl5Y0RSNFJUZ3ZkMnh2TURCWldRcG1WeXN4V0ZWQ2NGZHNk
      amxsYW0xTmVDdExRbFUwVVVsdEszUklXRlJZWTNwdmQwWXhSV0prZVV0MFRERnNZbVJvTWpKRVIw
      bElPRmxoWjJwbGJERlVDalYyV1hoNlMxZFNZakpZUlRKcVdWUjNlalJFZVhsNFJFUm9NMUJYTDI1
      dVNHZ3ZjemhXU1ZwYWVXVklSVFZGU0dWdk1YaHRlVFZXWlVJclZrZHRZU3NLVld0S0x5OWtTV1kz
      Umk5alIzbzJUWGhsZGs5VGVEQkNSRVJ6U25sNFFVbDNNVXdyT1UxamFpczRWMWxXWVZscWRtZzRi
      bmRqUTNwcFF5ODVaM05YYmdwVGVrcG9Ua1IwTVUxcEsxWXpkV05WYXpNelQySnVOM05sWVcwNFJF
      eGtOM053Tm05RVQybEVWamxIVDFGUlpsTkpUbFpzVW1GalpucGlMMVpVVUhCU0NqVkRPRXQ0V201
      WlFsSXpPVTFaV210VlNucElkMDl1Vm5KS1NXZGhRMUp4SzBSQlpucDRRWEJqY1RVMWNHRXhLM0F3
      UW5OeWMwRnhObkZDUm5wNE5pOEtLMjk0TmtsV1EzcFNjV2xUZFVSSE5rVTFaVE5VVmpsblVGRXlk
      VUZRUjNoamFYVmxURnBSWm05S1dteExkRlZFYW5WR2QzWklSbVpOT1RKaVFTdEdjZ3B4Tkc0Mk9W
      ZDJNR1JUYXowS1BURnhVeXNLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Remediate audit rules for network configuration for x86
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_rules_networkconfig_modification.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Remediate audit rules for network configuration for x86_64
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_rules_networkconfig_modification.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - sethostname
              - setdomainname
            syscall_grouping:
              - sethostname
              - setdomainname

        - name: Check existence of sethostname, setdomainname in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_rules_networkconfig_modification
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"

    - name: Check if watch rule for /etc/issue already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/issue\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /etc/issue in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/issue -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /etc/issue already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/issue\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /etc/issue in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/issue -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Check if watch rule for /etc/issue.net already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/issue.net\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /etc/issue.net in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/issue.net -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /etc/issue.net already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/issue.net\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /etc/issue.net in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/issue.net -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Check if watch rule for /etc/hosts already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/hosts\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /etc/hosts in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/hosts -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /etc/hosts already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/hosts\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /etc/hosts in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/hosts -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Check if watch rule for /etc/sysconfig/network already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/sysconfig/network\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key audit_rules_networkconfig_modification
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_rules_networkconfig_modification$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/audit_rules_networkconfig_modification.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_rules_networkconfig_modification.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /etc/sysconfig/network in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /etc/sysconfig/network already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/sysconfig/network\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /etc/sysconfig/network in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/sysconfig/network -p wa -k audit_rules_networkconfig_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Ensure auditd Collects Information on the Use of Privileged Commands - newgrp
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_privileged_commands,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects Information on the Use of Privileged Commands
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80724-8
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.2
    - audit_rules_privileged_commands
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXRqZG5jMU9FUXJhalZ3VGtGUmFrcGFRUzgzUWpGM2FF
      Tm1Vems0YUd0emFtWm1kV3QzWkdneGVqWTVObWx0TkRSUGIyd0tUR3BYVjFkS1ZGQjJZa0pDSzJw
      U1VWVXdRVlowWXpOWFJrUlNSVXBvY2pOa1pqSXJTWE5YU1V0WVJFNUVOak16Y2xBM2JsRXpSRzhy
      VFhOM1ZXdElkQXBMTWs5a1dDdGlRbmt2WkVaaWVuRm5kelZFZVhkTlZFbEVhVU5JVG5KdlNXSm9U
      ekl2TW5JMlZGTTVNRmhCZW5CcVpHWjNaRFp2YUZCbU1EQjNlR292Q21aYWVsWTFZbEJCV1hsWWJu
      TndjR2R0Y1dOQ2VXZ3hTMDlwU1hWNldsSXhjVkp2VHk5eFMxVnNWRmx6ZFhOdVl6TTJXbWR3Vm5a
      R2FUZFhMMEpWVERZS2NYUk1ZMWh1ZWxoT01FaHBObEJ5TDBKQ2FFbFdZVE5hUXpGSlIzZDVNVkJM
      ZUdjMVdrZDVibTV5U1djeVpETlVWV3BaVm1ZNFRXTkZVVGszV2xSTlVBcHNkRFJaZHpFMGIwbDNM
      MEl6VVhkS1Z6aDVWRkJ1Y1dGNVJXaHNlRzl4ZVRsaVJqQnphWFp6TVZoYWRHTnNhVEV6YkhkRGJV
      SjFSamwzVDA5bVJtOWpDamcxUzJoR1NYWk1OazFuYVRKVFRUTXhPVmx6VjA5TU1uVkxNSE0zZVZa
      RlRVbHFPVXRDWTNOVU5rUlZhV0ZoZEhWcllUSXZNMWh4UmpSblZFeEtUMWtLUm10TlVtOTVlRUo2
      Tm0xak5FZG5lVEJpZFZjeU1VSXdORTF4ZG5KV2VtOTRVWGN2T0hvNFMxUkhOWFJuUTFST1FXdEpk
      SHBLWWpVeldYUnVSM2QzZHdwSE55OTBTelJRUmxaMlRtVnpNa2xSTlZkclJsWXJTRE01YkdkRVJr
      SnlabGxoU0ZkNVZpOTFjVVoxYm5Cdlp6TllSblJCWVc5NlRUZHNSVkpyTlhGUUNsUnBWMGhwY0ZS
      NU1tZEROM1Z4WmxKRVFuUlBVbXBSY1dOVFREaDFTV2xuVFZOT1VEVkZSSE55YlhrMVJrSTRaVUo2
      UmxVeVdHeEJUVkIwZG5aUFJVZ0tVMGxhVEU5T2JVUjJSRzQwVDFkaVQwRnNaSEJuYkM5MFNuVXpi
      V1l6Y1hkSVEyNXpWRTAwUmpCa1REaFRVV1I2Vm5RdkszRkJWV3R5ZGpGbE5XUmlUQXA0WjJOVGNt
      VXpiM2RKVlQwS1BYbFRhVGdLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Search for privileged commands
      shell: |
        set -o pipefail
        find / -not \( -fstype afs -o -fstype ceph -o -fstype cifs -o -fstype smb3 -o -fstype smbfs -o -fstype sshfs -o -fstype ncpfs -o -fstype ncp -o -fstype nfs -o -fstype nfs4 -o -fstype gfs -o -fstype gfs2 -o -fstype glusterfs -o -fstype gpfs -o -fstype pvfs2 -o -fstype ocfs2 -o -fstype lustre -o -fstype davfs -o -fstype fuse.sshfs \) -type f \( -perm -4000 -o -perm -2000 \) 2> /dev/null
      args:
        warn: false
        executable: /bin/bash
      check_mode: false
      register: find_result
      changed_when: false
      failed_when: false
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for audit rule entries
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: ^.*path={{ item }} .*$
        patterns: '*.rules'
      with_items:
        - '{{ find_result.stdout_lines }}'
      register: files_result
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Overwrites the rule in rules.d
      lineinfile:
        path: '{{ item.1.path }}'
        line: -a always,exit -F path={{ item.0.item }} -F auid>=1000 -F auid!=unset -F key=privileged
        create: false
        regexp: ^.*path={{ item.0.item }} .*$
      with_subelements:
        - '{{ files_result.results }}'
        - files
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Adds the rule in rules.d
      lineinfile:
        path: /etc/audit/rules.d/privileged.rules
        line: -a always,exit -F path={{ item.item }} -F auid>=1000 -F auid!=unset -F key=privileged
        create: true
      with_items:
        - '{{ files_result.results }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - files_result.results is defined and item.matched == 0

    - name: Inserts/replaces the rule in audit.rules
      lineinfile:
        path: /etc/audit/audit.rules
        line: -a always,exit -F path={{ item.item }} -F auid>=1000 -F auid!=unset -F key=privileged
        create: true
        regexp: ^.*path={{ item.item }} .*$
      with_items:
        - '{{ files_result.results }}'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record Attempts to Alter Process and Session Initiation Information
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_session_events,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Process and Session Initiation Information
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80742-0
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.3
    - audit_rules_session_events
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXRqZG5jMU9FUXJhalZ3VGtGUmFYZFNVUzhyVGl0UGVI
      bEthalpNTmxOb1FXZFNRV2hOYzFReVFsRmpjbGN2TXk5WVVYY0tjVEo2UTJ4VVl6QktXbHBGV2s0
      MVJrNVVXRzVsWjNCR1IyOUxUVnBpV1VST1dGZDBMM1pxZVVaV2VVbHpkMWc0VUhKVFdVdG1jRmxK
      ZUdWc1JrSm1NUXBxUkVVd1F6TlJjMlJPTVdVd2FWRjJaalpFTld4SVUyMTZNR1pVTWpKWU9XRmlX
      R05xU25oM1QwbDBTemxCTW1GNlNteFpaR2d6TkUxRk4zRTFNM2R5Q21aSmNGZERXbFptTTA1SWR6
      VmxTWEJLTDBKdE0zWkhWRVV5YUROd2QxWkplakF2TlUwdmJURkRabTlCSzA5NVVUY3dUMkU1Vmxo
      TFRISXZlbXh1UWxrS1NEWXZiR05oV1VOclMxbHZlSGhhVW5wTFQxTlhPRTF5Y1dkcFVYY3JkRUl2
      YjBkdFJEQnJiMU13ZGs1aGVub3JNRXh5ZFRKRlRIQTFhMmRUYTFSMWJncEZNRkJrSzB4WlJFZHJX
      R05FTDFWRlFYcDFWRkozUWtWUVVscHdVMGxITkRJNFdXeHFiSFJIV2xkdU5uQndPV1JqVXl0S2NE
      WTFTRFpXV1ZoYVIxRm5Dazh4WVVWNWQwaHBlVlpDZVRSWU4wdDRhamczT1RZMWVqSlVjMkk1VUVW
      SE5URkJkazFVVG5CUGFXNVVNRkE1Vm1KbFRtUjVUV1J6Y2xOSmMxQTNhbUVLVG1Od04ySjVUbGxD
      WjBwcGFtZGxTa05LT1VseFJIVlRVblJxT0c1R01YcFNhbGxXVUhCMFlWRnpXVmRHZURCNVZXOTNj
      WE5vTXpCYWJFRnBXRmw0UndwdWJqTnBNME52ZHpGemIyWlBkbkIyS3pCTGNuTm5iaTlrZGsxbE9E
      RlRVbkZtVm5wSllqZ3dZVzg1VGpoRVlXNVBhR3B0YTNwME5uVlVSVEl6VGs5TUNrOUtXR1IxYTNw
      M01uUnJTRGQxU21GYWQzZEhSME15VlhaeloyeEVWMmh0VG1wcVdUQkZOV0pFVTFOblFXOW1TekJu
      YjBSa2FsaFJZVEYzYW0xWmFFOEtXa2xEVmsxaFNrMVpSWFpFU1RWWE4yRnBRMmRHUTBkRFdGSlRT
      bW9yZFNzMVZFOWtXVU50ZGxOVlNXbzFSRm8yYWtOQlptMVJNVzlPVmxCcGRqbHJVd28xTkdWWGEx
      RnFlbkJJU1QwS1BWTnRRVklLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Check if watch rule for /var/run/utmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/run/utmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /var/run/utmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/run/utmp -p wa -k session
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /var/run/utmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/run/utmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /var/run/utmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/run/utmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Check if watch rule for /var/log/btmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/btmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /var/log/btmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/btmp -p wa -k session
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /var/log/btmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/btmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /var/log/btmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/btmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0

    - name: Check if watch rule for /var/log/wtmp already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/var/log/wtmp\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key session
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)session$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/session.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/session.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /var/log/wtmp in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /var/log/wtmp -p wa -k session
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /var/log/wtmp already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/var/log/wtmp\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /var/log/wtmp in /etc/audit/audit.rules
      lineinfile:
        line: -w /var/log/wtmp -p wa -k session
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Ensure auditd Collects System Administrator Actions
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_sysadmin_actions,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Ensure auditd Collects System Administrator Actions
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80743-8
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(7)(b)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.2
    - PCI-DSS-Req-10.2.5.b
    - audit_rules_sysadmin_actions
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXRqZG5jMU9FUXJhalZ3VGtGUmFWbEZVUzg1U0RGeE5s
      Vk5SR00wV2xKeVkyWjNhRmRITWxVM1VXVjZWbE0wWXpsNFFWTUtZV1Y2Y1RSalNTOWllVTlaYUZk
      T1IxVm9kMWhwZEZsS1FWTTJVbFppYlc4eGRqVnJVbkYwYzNWbFltd3ZZemhyVW1KRk9VMWtNMk4x
      WlhKMFNFSklZZ3BIT0hGQ1RXVmhRbEZFUTJWSmNWQnFVRlJsUjFvNE5VSnpORTlsUVZSeGMyaDZM
      MjlHZEhGR05XMW5jVzFrYlVSYVlrSXJWRlZWYzJ0a09FOTFSR1Z1Q25CbVlrUkxaalJ3TDBwYU1I
      ZFNMMEY1YTB4dloydFFiMVYyVldSRE1uVjFMelJHYjFkWFRIZGtUV1JSZVhrcldrUkpNRFpPYkZZ
      M056UkpPR0ZOZWk4S1EwazBMMGRRVDBwc1VsSlRZbVJXYjBOT2FFbFJlRXRMVDJwMUx5dGlNa3Ru
      ZUZkV1lXZEVOVFJFUWxWWGRVWkJkVGxyYm1sWWRGSnhNVXhwYWpsRGJncEthRWszWVdGc2VuVkVS
      a3B2TnlzeVFWaE5VWHAzVFRkRmJYUjFVRVJOUkV0M00wUlRhM0prT0dRNFJtdzNiazlzTjJ4VWEz
      WllXVVIzYm01RlNESnFDa0oyYUZjd2IxY3liMjQzUWxjdk9WWXpOVkZRUTAxa1JHRldiazU0ZDB3
      elNURTViRVp5WVVSbVlpczVhV1ZqZFZSS2VVNUVkRWhNY205c01tOUNkVlFLUkU1TFNGWkVheXN3
      WkM5UVpEVnhhRXQzZVhaa1UzbE9iM1JpYUN0V1FUVXZiMmxxU201VlNsTlRVV3hrT0hORmNHdEdl
      VTVIYTFZMFNuQlJRWGx1YmdweFdEQkxPVnAwZWpsSWNIRm9OVm80UVdRMVdtMUJZVEYxY1VaSVQw
      MU9TazFsWVZSbWFsUm5jQzk0U0Voc1JFWjFPRlZPTjFRNGJsUXpUbEZaYm1KMUNteExRakpzTkdW
      cFRuWTFTR3hOVUdzM0wwWktORTkwTVdwVGMxSm1lVTFvUjJocU5UbExLekEwY0ZSbmFITXhOVXBQ
      UXl0RlEyWTNUVTB4T0RoQ09XWUtRMUJhV2paS1JqbFpjVzVqWVVSQ1RHZDZjbFJMWmt0SVYzUm9U
      MjFRTlVReFZXVkNlRkoyVFdrNFRXTldWalU0ZEc5RE1VcFdZWGQxVG01Q1VrRmlSd3BtVXpWVmVT
      dElMelF5ZHowS1BTOTFTRkVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Search /etc/audit/rules.d for audit rule entries for sysadmin actions
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: ^.*/etc/sudoers.*$
        patterns: '*.rules'
      register: find_audit_sysadmin_actions
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Use /etc/audit/rules.d/actions.rules as the recipient for the rule
      set_fact:
        all_sysadmin_actions_files:
          - /etc/audit/rules.d/actions.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_audit_sysadmin_actions.matched is defined and find_audit_sysadmin_actions.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_sysadmin_actions_files:
          - '{{ find_audit_sysadmin_actions.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_audit_sysadmin_actions.matched is defined and find_audit_sysadmin_actions.matched > 0

    - name: Inserts/replaces audit rule for /etc/sudoers rule in rules.d
      lineinfile:
        path: '{{ all_sysadmin_actions_files[0] }}'
        line: -w /etc/sudoers -p wa -k actions
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces audit rule for /etc/sudoers.d rule in rules.d
      lineinfile:
        path: '{{ all_sysadmin_actions_files[0] }}'
        line: -w /etc/sudoers.d/ -p wa -k actions
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces audit rule for /etc/sudoers in audit.rules
      lineinfile:
        path: /etc/audit/audit.rules
        line: -w /etc/sudoers -p wa -k actions
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces audit rule for /etc/sudoers.d in audit.rules
      lineinfile:
        path: /etc/audit/audit.rules
        line: -w /etc/sudoers.d/ -p wa -k actions
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record attempts to alter time through adjtimex
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_time_adjtimex,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record attempts to alter time through adjtimex
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80745-3
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - audit_rules_time_adjtimex
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXR6ZG5jMU9FUXJhalZ3VGtGUmFGTk1keTh2VjBSdlp6
      bGljRmRLZVVWaVdteHdZM281ZGlzdlVWWlhjakEyTm5kRGMza0taV3gwT0VKQ1MyMU5XVU5zVW5a
      UmEyWlNiMDVGYnpsblUxbDNUMmRXWWxCTVowbGtaSHBCT0V4WWFtRktRekZKUW5weFFrRkJhVVpV
      ZUZobmRpOXFVQW9yYm5kMWMwWkdkRE5QUW1SamVGWnBTV1pJWjI1WWVEZG1NV1owYlUxeFNYZFZN
      VFphVURGQ1lsTXpSWFJJVkZKSU9VMUViMDVvTTFWSVpVVktWVmwzQ25CNFZFZ3dObkZ6Y0VacVRt
      VjZWalJDV0VKU1oyTjZla0UzY2tWTlRtZE9hREJQV2xOdlkySTVUVXRNVkdaNlF6SXphMlZZYlds
      WlprRlRjV0oyTVRRS1ZWRXZXa2swVUhrd01VVXhVVnBsYnpoRFluSjRlRVYwYlVVd2RtTjRiRkpr
      U2pFclNEWnZjMHA2T0cxaE4zSlBSV1Y1ZVVWNGMycE1TM3BqWkVKdlFRcGpXaTh4TTJncmMzZHpV
      RUU0UkVwclUycENhMGhGU3pSM2NXOHhiV3hWV25KRVVtSXpRMWRNUkVSbFdHUm9kV3AzZFZWU1RG
      Y3ZOVk5DU1dSMFR5OVZDblZEZUcxTmNYUlRNbk5vYlhCS2MzQlpUVE42VTJKUVJtUXJWVGxNWXpW
      S1IyY3pTMHczSzJKdGRVWjNVREIwV25aUk1GUk1TaTlNWlZKSlJYbFJWR2NLZGtoMFVqSjJTMVZR
      VkZGS1owWkdSSE5ZV25kVFZ6ZDNXSGR4TTJWbVUzTTVha0p2YTFCMk1tRjJlamxqVW5CMlYzbzRN
      MFlyYlRaUkswbHBSa1ZCTlFvMVFVVnBVRk5XV1RKdGVrVk5WRlpaZUdsSGJscDJMMk5OVEdScU1H
      Uk1WVnBVYmpOM2NFVXJUWEpWWkhnNWJ6ZGFUMXAwTm5wdE5teEVibVpNTjNBeENtNDBja1JrU2xC
      amQySnpNelp6UkdoeWVUVk5NVEZMU2tKVVVTc3dOWHBqZEVKUVQyWlZVakIwVUN0cU5uQlVibXg2
      VXpGaE5FSmpSV0ZTVmtJNWJUY0tXRFJZYTBWelZEUkxSR3Q0TkVsQk5DdFNhelphWld4RFptNVli
      bkZDVWxKeFRrMURlV0UzTVhWU2VYVnNkRFo1V20weU0wY3haWGs0TUhGblRVZ3dUZ3B2TlRkbVFr
      TlBLMk5pWXowS1BXUXlhVzRLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for adjtimex for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of adjtimex in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of adjtimex in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for adjtimex for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday

        - name: Check existence of adjtimex in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - adjtimex
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of adjtimex in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Attempts to Alter Time Through clock_settime
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_time_clock_settime,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Time Through clock_settime
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80746-1
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - audit_rules_time_clock_settime
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXR6ZG5jMU9FUXJhalZ3VGtGUmFXeE9Va0ZCYmpaVFdW
      aExRVlZtTkc5d1UzUk1TRUZKZEd0VFNHOXpRbGRaTjBObmVtMEtkRkI0VWxkMGVXWlpaakVyVVRo
      SFdqQXdPSGN5VnpaU1NsZERSMnByZEhBNVVVSjRlRUZEUzJnNE9VSTVWV1puVEVoVFdscEdURThy
      Y1V0NUt6SnVOQXByVVRoNlJYaG9MMmRwWm5sbFZqQlRjbkl6TUZnMk5tWmlZMnQxWlVsbll5OUNU
      a1pVV21Gck1UUTJXSFZ3VDBaMldXeGlXbFZGWnpWd2JESjFXbUpHQ2xrNVZVTkxTM0ZQYkdOUU9Y
      aFdVekI2Y1cwMFQxZHRTMGRJTlcxWE1qSjNha05yWWpodVowVnhVRkpuWTJVeFFUUTRiMFJXUmtO
      WFVVMUNhV1IwVm5VS1ZYaFlWMlV5U1RCWmFrTlBTbU5NY25aYVlYVlpRakJPV2pObk4zQmhVMk0x
      V2xKS2JVNVpUVzhyTURaU1kzbFhlVlpQYUdaalVqUnhWa1pRT1ZocE13cEVaMmxNUm5sTFMwWkli
      Rk5OT0hKTVYxQmxWV0k1VWtkR1QwWm1aalpGZEVoakx6SXJhRzV5VGxkNU4yNHZkSFYyWTBkRmRG
      ZFFSazh4U1hKWlpscFRDa0UyVTBGaFNHTldlVWhDTkVsU2NsUjJUMklyZDA1WmRGVlRTa3RFZG1k
      T1JXOTJhV1pYTlhWTE9GTjZlbEZZVm1aMmRXeGhhMUpLVVc1VGFFbGlRWG9LVVdsRlpGVmtOMWh2
      VjBwcU5sVkpSV1VyU1hsbGEwZDFhR3h4Tm10eVRWTjFkRmRNUTJkVVMya3pla1Z4UjFsS1JXSlJl
      R1pMUzBoclYwbENiMjEzVndvNVJtVjJaemQyYlhKbEwyaG9PRlZYYWlzNEsxbHNVbXhhV25kdU9X
      dzFNVTQyVnpWWE9VWjFTbkJsUlZwNlNrbEtlRXhaWkVnNGJVSlBaRzQyVFRjNUNrNWlaM0EwU0ZK
      Nk1EUmFhbTlWT1RBM1UyNDVPSFZTTTJod1UxWTNTME5zTWtOUVZuRkhjMmsxU2xOaU16QkNTRnBt
      U0V4V1FUaGFTRm96VkU4dmNISUtTeTlTVTFZclpHbFRjVzVwVDNGV1FVcHpTRzVMZERBMVZETkpW
      bVpQWTFkUVUxcHVVM1IxU2tkWGIxVjNWWGx6T0dNNGJVWnNhbXhYWVdOc2FHUmtSUXBMUzBSdVdI
      Rk1TMWgzWnowS1BXNDVNa2dLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for clock_settime for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules
          set_fact: audit_file="/etc/audit/rules.d/time-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for clock_settime for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/time-change.rules
          set_fact: audit_file="/etc/audit/rules.d/time-change.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - clock_settime
            syscall_grouping: []

        - name: Check existence of clock_settime in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F a0=0x0 (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F a0=0x0 (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F a0=0x0 -F key=time-change
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record attempts to alter time through settimeofday
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_time_settimeofday,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record attempts to alter time through settimeofday
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80747-9
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - audit_rules_time_settimeofday
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXM0ZG5jMU9FUXJhalZ3VGtGUmFTOVRRUzh2WldkcmRG
      UkhkRXM0TkVnMU0yTlROVzgzYzNOUlpEWnhlVE5NWWl0aWFsTUtZbkl3WTNOUlRVaEdSekZSSzAx
      VFRqTnZWbkZCZFRWSWJYSlpSak5tV1V4YWJucHVabmx1WldsbVZFRlNlazlaTjBsU01uTjVOVXQ1
      V1hwdVZWSndSZ3BET1U0eGFVWmFPV00zYWpSWWNVVmlWV001V2poUmNGcFlTMlkyU0ZJMWJ6aE1a
      bGNyV2xWQ05FOXlXa2R5VWxNd01tbExPRnB6VFdWNmVTdEhNV3hHQ2tkaFoyTktTWFU1UmpWUWJq
      RmpiV0p3V210UmNYWmlTemhJVWswd01pdHBTSEJ5VEVkRVlVTmxPRVp3ZDNKVmNVbHVhazUyWm5C
      S2FtdDRjREp1TldVS09UVm1WbmhMZEdaS0wwRllXR3MyWVM5WlUyaEtXbVF2V0hGM05IVmtOR0ZJ
      ZEVKemJFaElPUzlMZUZoMFNHcE5ZbUozVlVGQmVXUjBjRVE1TW13MlFnbzRNRzVGTVhSSGVqZHpT
      bGR6U2pBMmFIUXlWbWhpY1ZndlZGVnJaRzlRSzAwMk5FVnZTVGxoTkhJMWJ6QlhZa0k1WWsweE1V
      ZEZhVXhDUkhwa1FUVkhDa3hIWlhsWWRVeG5jbHB4UW5neFJIZHNjamRCVFVWRU1tUnRWMnhJZEM5
      NVkzQjFWbTlzYjNCNlVUaEJla3hRVEZrNFNHbERVek5RUjBneVoyeG9VV3dLUkVkb05VVndUV2R3
      VjNsTE1sbFdibkJXZEZwdFYxbFdRblU1WVZBemRWb3pTbWx4WkZWaGJFMXRiM2hOT0V0UFJWY3hV
      RWRoU0UxbGVXdHZXREEwU0FvMlFVdEdVVEZQYmxnNEsxaHVLMmR3ZGt0MldrcFVRM1Z0VDAxbWFt
      Vm9ibXhYT1hKQlFtTk1jVE5SZDFZMGRqVmxObkJRWkdFMVdsTmpXVzFFUzBWTENsQlpVMXBrTkds
      VU1YZzJSVE5SZFRKdmFqbFNURUUzWjA1RVVIbDVjSHBYU2tvd1JWZGxVRlV3YnpkeFJXaHdORGRX
      YWxnMFRIb3hiVVpIVFZGcWNETUtOVmRSY0hjclYzbFZXVFZ5U1dOSVNXOXFWa1pUUTNkUE4ybDBk
      bmRyVHpKemQxUlFNbVpQTjNadVowUXZPSFE1WVd0b1kxSktTVGxrTUVOb1RVTlRkZ3BhZVc4NE5U
      UlJaREZPYXowS1BUQXhOSG9LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for settimeofday for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for settimeofday for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - settimeofday
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of settimeofday in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Attempts to Alter Time Through stime
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_time_stime,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter Time Through stime
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80748-7
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - audit_rules_time_stime
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeXM0ZG5jMU9FUXJhalZ3VGtGUmFYTnFVUzhyU1VwdGJU
      UktSbW8yVlU1UVYwVlpXbnA1VEd4U1oxWlpTMjVMUkc5R05VY0tPV00zU3poclJ6Z3ZLekJCTjAx
      MmVTOWhUa05HU0dwSFVrUjRWSGRTUW01NlExcDBTV013TVdFd1FrTnhlVGRFYUhGWWNtVllhVXAz
      WVVveGFreHRhUXA1ZHpWbVVUZGlhMFJuYUdSMmJWaFJhMW8xV1U5ek5tWnZRakZNZUdKNmMxTnpS
      RlJhZVhJNFNrWXhkMnQwWkhsUmIwZGhORmxMV1hKYU1saFBXVmhTQ25WMVkzZFhabGRLZEdSdVNH
      bEJWWGRDYkZOMFdsUkNhRVpJWVhReGFrMHdXVXMxV1dSb05TOUxTVkYwV0RGeVVHY3hTazlFTjBG
      dmFDOVpSMWRTWVdzS1MycE5lbGRNV0dKRFNFWkxNM1JsYjBkM1ZVeEhhalZRWVhScFRpOUVXSHBQ
      WVZoVlpWbE9SR1ZMTXpCa05tSm9LeXR6U1d0eVlVcHVlamd4U0RVcmRBcHNLek5RY2tGNVQxbFZh
      MHQyTkhaNVExSk9NbFJvVVhJd05GRlhjaXRaVnpKbk5uZHplR1pSWW5SdVpFdFlOMlp1YVhkWFRq
      TkVhMDE0WjJwcFoydG1DbTFsWmpsMmExZE9VQzl3TW5rM2IwTkRZVlowTldKblVsb3JORll2U1hW
      T1IzRnRRVzFwUTA1c1lUZG9WSEZuY21JeVRtTXJRVEpHZEdKMVVEVkpVVllLZW5RemVYQnVSbHBD
      TWs5VFdEbDJjVEJGTW5kd1kwdE9Za3A2ZEVkWlNXVnRXbGxhU0hwUmVuVlBXRWM1YjNoc01rcFhl
      bUowV0dOSE5VNTFUWEUxS3dwc2FFZ3hSbUl3WTJkbFpHOVBTVTVSTkVKMGNVTTRXbHBGVFRkVFlW
      TjRTRzltVEZSa1NXazBlbFpxT1doemQwODBiVWRITW5CUWNWTXhiRzlKUTJoUENpdExSM1kxY1VS
      dVVqVk5ka0ZTT1N0V1IwbDJXSE4xSzBoelltWjNUeTkzVEhoeFVFVnJUWHB5UmpaWE5reGlaMFJG
      VGxaRk9HTmljbFI2V2s5MmFtRUtWekZhY0hSNlZURmxlV2RPZFVkVVpVOXhPVzB2Y0c5MlZERkZh
      a2xzZUcxWGFFZzRhWHAyYzJkWU1Vb3dPVzlZVEZVNWVHaDBRMWhhV1ZSWmNIRk1UZ3BtYlcweFZt
      aHJlRVJJUlQwS1BYbFRURmdLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Perform remediation of Audit rules for stime syscall for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - stime
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of stime in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/audit_time_rules.rules
          set_fact: audit_file="/etc/audit/rules.d/audit_time_rules.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - stime
            syscall_grouping:
              - adjtimex
              - settimeofday
              - stime

        - name: Check existence of stime in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F key=audit_time_rules
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record Attempts to Alter the localtime File
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_time_watch_localtime,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Attempts to Alter the localtime File
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80749-5
    - CJIS-5.4.1.1
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.4.2.b
    - audit_rules_time_watch_localtime
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeTlOZG5jMU9FUXJhalZ3VGtGUmFVNHZVUzg1UjJ0WlNp
      OWtiMEowVG1kaGJVNXFVRVkzV0ZVNVNtWktiR2hvVVd4blJFd0tZelF3WjFOVFlXNTRWbTR6V0Ux
      TVRrSmtiQzl5ZFhRMVVFbFVjWFJhZDA5cFdrcHJNMWRXZFZSemNWUm1hRWRXUzFoTmQzTldlREpK
      YXpGalpFUjJVd294VUdWNmRsZzFNbWhKY1hKbllrZGllRVl6V0ROalJXMXpUbmhWWkhBMGNtWjNW
      RzVWVW1OdFozbGlWVkV2WmxJd1VVUXpiVEo2YjNkeVNqaElTelJuQ2pBdlZFSjZaME51T1c1WWJ6
      Z3JibVZEZFVnMUsweE5jaXRMU1daclRVNUtSVzFaWjNVdmFEUnJiRU1yZFVVMU0xZGtTVFIxYjNG
      SmQzRnJabGRDZWk4S1VXNU1lbWhOYW14cVZHeDJaRU4yVEdOTE1WcEVabFpOTDNrdmQyUnZjRzEz
      TTBoR1MwbHljVTl6ZGxObFdHbEtWekEzUm5aMGVHWkVSa0pCZDFvM01RcDNkRzV5YURjcldUWnJW
      VkY1TkVaSWIzZ3dWbEJ2YW14c1dXTldSMjFMYXpSelNXUndTVTlIV0c5MFluQXpWa1F2YkU5WE5X
      VXpSR2wwWTJ4WlZpdHpDbVpFU0RJNWQxUndTbmR4Y2pCaWExcGFieXRFTDA4d1RtaFVSRUZ3UjFW
      WVNGQkVPWFpOWVcxdWFtSkVWR2xVUjJZMFEzRkVNRzVHY0ZKaVVHVjRjMm9LVkZrd0wyWk5jWEJK
      YzA4NVRHdEplV3RaVm14NVYyVlpiSGRXZFNzMWVXMHdSa3RJSzBKeVNXNXhVSFkyVjJaSlpXcFhR
      WE5sU1haNVIyaFhXa3BzVXdwdFMyMWtRWFE0Y2xkNFJYZGFlRzVrVm1veWNpc3dZVlpCTjFscGNV
      cDBNR2R5UkVab05VNTBZMFoyUjJGd1JFdHZkbkJMV0RrdllVb3dNRFY0YnpOc0NqSkNhbkp3UTFO
      cVRqSkdkRWRNTDFGbFJIRXZkeko0WlhJM1REVmFPVGt4T1V3clEybzVVMnRQYUZwRFRIbE9SMGN2
      TW5OVFJVVnNWWFY2YUVaV1FYUUtibFZHZEN0U1QwOXhTVll4ZUZOTGFXNW1kakZtWTFsVlVXOTFZ
      alkyWTFOTlRFNUNORXgwZEhKTlVUVk5aRTFRVjNob1NHdDNVVGx2V1cxdVNrZE9WZ28xUTJsMWJt
      WnlXWGxHTUQwS1BXTnZRbVlLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Check if watch rule for /etc/localtime already exists in /etc/audit/rules.d/
      find:
        paths: /etc/audit/rules.d
        contains: ^\s*-w\s+/etc/localtime\s+-p\s+wa(\s|$)+
        patterns: '*.rules'
      register: find_existing_watch_rules_d
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other rules with specified key audit_time_rules
      find:
        paths: /etc/audit/rules.d
        contains: ^.*(?:-F key=|-k\s+)audit_time_rules$
        patterns: '*.rules'
      register: find_watch_key
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use /etc/audit/rules.d/audit_time_rules.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/audit_time_rules.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched == 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_watch_key.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_watch_key.matched is defined and find_watch_key.matched > 0 and find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Add watch rule for /etc/localtime in /etc/audit/rules.d/
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/localtime -p wa -k audit_time_rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_rules_d.matched is defined and find_existing_watch_rules_d.matched == 0

    - name: Check if watch rule for /etc/localtime already exists in /etc/audit/audit.rules
      find:
        paths: /etc/audit/
        contains: ^\s*-w\s+/etc/localtime\s+-p\s+wa(\s|$)+
        patterns: audit.rules
      register: find_existing_watch_audit_rules
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Add watch rule for /etc/localtime in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/localtime -p wa -k audit_time_rules
        state: present
        dest: /etc/audit/audit.rules
        create: true
        mode: '0640'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_existing_watch_audit_rules.matched is defined and find_existing_watch_audit_rules.matched == 0


# Record Unsuccessful Access Attempts to Files - creat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_creat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - creat
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80751-1
    - DISA-STIG-RHEL-08-030470
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_creat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeTlOZG5jMU9FUXJhalZ3VGtGUmFscFJVa0ZCYW5kR1RW
      SjVOMEZFUm1WWWNDdFBMMjB6VHpSUWJpOW9aV0ZaYzJKM1pHd0tSREJZV0ROdU4ydERRV1l5ZGxW
      RGJWbEdWRkF5V25wWk5rWmFRbXQzUlZSQ05IQTVMMkZ1U0UxdWQyeGFUamR6VVdVeE9GVmhNRXgz
      ZVRNMFkzSlFVd29ySzBoaVMzcGpNMHhNVTNoRGJUZGxPR0pDVG5oRlkxZHRhSGhQY2xkWUsyWTVT
      RE5RTldsaVYyZFlVV0ZDWmpWU2NuZzBhM04wVG1GeWN6UXJPSE51Q2pSdmNuUkxlSEpsVW1OelUy
      Sm9NMU53TmxNeWVHVmphbUZOYm5SSlRWSnZMMmR3UjNGMVQxSnpVbGdyV1VWbFlUQTJhSFl5U1Zw
      YVprNXdTbGxxVFVZS1oycHBWRXhHZDIxaE4xSXJkbWxMZURWVFZrNVpNVWMyUVRCWFoyMDBPREp5
      V0RkWVYzZzBiWFU0WVZkNVpEaHhXbGxMVEVOcFpsQk5hVFpVYlRaMU1BcHBiMjFRT0RKbFUwcFRR
      WEJhTnpBM0wxQkJNbHBoVW1ScmVucEJLM0E1Y1dvclJYUk5MMVJFV0RSclVWcGhlVEJwTlhkR1Rr
      MXZWRU5RYTFsbUsyVkNDa2hDVERCdGJYWjZUR2RuWW1SS1pHczRRWHBaWmxBNVNDczBkRUl2Wlc5
      eU1UQTVhelI1VWtGWU1YZFpiVnBxYUV4SVdYWnhhU3MxVkhnelRUaFFUWFVLVmpObGNGWkZjRVU0
      V2l0Q2RFY3hhWEpWY25KQlRtUldWV1pHWkV0NmRIbHNOalp3YlZNclNsazNhWFZIVTA5aGRrbDBV
      V2hXYXpSVVduUmxXbFprVkFwVFlsaHNXVUpLWm5oUGNsVm9aakpLV0ZOa1FUSTFiMHRSV1dSRmFY
      UXpNM1Y0TlRSMU4zZGxkbE5KVFZOdVZVNXVSMmREWTFkVWVtSlBSMmx0V0d4MkNrRkJORUV3TWtk
      bWFqazJNR1IxWWxCTVdubEZUbTlEYXpablNXODNSbnBYU1RSWVRVbENhbTlzTDNoVVZHOU5MMmRv
      Tkd0S1ltaHpRMnhtVkhJNFluY0tRVmhpZVRoRllYTktha05YVTJOd05HcE9VRVpGZUc5a1dIQlJT
      SFZLTjFwSk9XSTFaRGhMZEVOek9EUTRSakZLY0ZKa2FFd3JkMU0wYURoWWIzcFRlQXBOWjNkR1Vt
      OXlhak5JVFQwS1BUaHZURW9LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit creat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for creat EACCES for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for creat EACCES for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for creat EPERM for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for creat EPERM for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - creat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of creat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - ftruncate
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_ftruncate,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - ftruncate
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80752-9
    - DISA-STIG-RHEL-08-030460
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_ftruncate
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeTlqZG5jMU9FUXJhalZ3VGtGUlowVm1keTh2V0ZGR1ZV
      RlpOM2xKUVdSbmVFeG1TVzVqVmxVMlp6aEdWWFJsWTA5TFRrb0taRU5yVlRsS2JFVkZRVzlzZGl0
      SlVGSTVURE5IVFdnNWEycGthR2xHVTBOMFRXdERlRTAyUzFjd2JGQjVhRXBLWjFWUk9GUkhaWGg0
      ZEZoMVEwNVpkQW81VEM5c09URkxkVnBRV2pCVVQybFlZVTVhVTFoREwwdG5kRU51WVVGeUwzUkNk
      MlZYY3l0bVMxbEZVVXc0UTJ4NGRHUlZRamhqYW1wQmRVbE9PSGc1Q2tZMVNIZHpjR3hKT0VKUmJG
      QnpRbWQwUkZKTVdFaERlaTk2UTBKbWNYVklWRk1yVlU1R2IwdGxPRTB5VFRJMUsxWk5hVzFxYWpo
      VFJVbzVSME5xVkdRS2RGVllhRTh6ZUhKNGVsWlZTa3RqV1VabWQzRTBVR0U0ZGxrclNUVTNXVFZE
      YUZKeE0xSjFhbTAwTld0NlRteEJkM2xsT0daaFFYWldaRU5UU2tWWlNBcEdUMFJvUjJReWRXbFZT
      R1Y1TVdvclQxSnhOR1ZWWVhKdlNGQkNaamN2ZVdGeFFsY3hiRVZKVFRWblMxUkJjV00wWjIweFEw
      ZGtkVGgxY1VKVVMyWlhDbGt3YUU1MWFHbzNiVkpxUzNvclRHRjZiMVZJYVhKVVRGRlpPVEp1VUN0
      elYzQlNZMUo1TlVGeFJXdFJXRVZyVERRM1lsUkJaMk1yTVZWb2VrSmxiV3dLTm1SYVFWbExSR1pG
      U1RKTU9UVlVRWHBDZFZodGMySkZiREJrTVUxVmJHb3JVMlZZTmpZMlZuUmxRVzVIVEd4TWNrazJk
      VlIwYnpkU1JDczFkRmN6UmdwdVNub3ZWMk5qVVZWcE0wVnhhV1pJTTBKM1JIVmliVXhrWWtkQlpI
      Wm1TSFZ6WTBSTFZtY3lZbHByTUc1R1YzazJTbFpTZEdzMmEzUnNSM2RsVG1wVENrTmlWVWQwZVZZ
      ME56bEJXazk0V1dkSlVEaDFURVZGWWxsdVZrY3dVbXd6VjBoalZHSnJabU5vYWpoVU5HRm1lRkph
      YXpjeGRIQmhUbTFLTW5oalpERUtaVXRqUWxBd2RXbDNkRGc1TW05UlJWTjBOa05QVVRkeFVuSnNP
      SFZuTDI1MFFVOXJaREJRTWl0T1lrZzNaRTFzT0d4aFdFeHRZVVFyU1RkNE1qaE1Md3BMWjIxaGEx
      UjBZM2RMWnowS1BUaE9ORzhLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit ftruncate tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for ftruncate EACCES for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for ftruncate EACCES for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for ftruncate EPERM for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for ftruncate EPERM for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - ftruncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of ftruncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - open_by_handle_at
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - open
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80753-7
    - DISA-STIG-RHEL-08-030440
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_open
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeTl6ZG5jMU9FUXJhalZ3VGtGUmFtdFRVUzh2VVRSMllW
      ZEdPRVZ6VFhSMU5VSmtLMm95Y1hWTFJVRm5jRms1VUV0VFUzQUtaVGcwVlRWcU1HeFRVM0ZwYkVs
      SmJHOWpiblJoYUc5NU16RllSMjlSUjJGUVRTOXdTazR4VFZaRWN6SkxZbVp2UWk5UWVGQkdhbXha
      UWs4NE1WbGFPUXA0VVZob1RtNWthalIwUTJVelYzRnROVmxzWW00ck0wRkNhMmxOV1U0MVluVmtV
      MGRCVFVacU0ycHNUM0p1ZG5OVFpWbFBWUzlGTW5veFowUm9UeTgwQ2tGWlEwdEdNV3RZYnpWRlVY
      bHRjbEJpTlVkd1IxZ3piRlpzVG10QlIydEtWR2g0U1hSRGQyNURUMnhXUW5kWVZreGhMMnQwZG5S
      ck5XZHBkU3RYVUhjS1NuZG9VVU5DWXlzNGJUVXhPRzlWT0Znd1NqTnpZblkyZGsxcWFWQklNbFp3
      YjFSeFJtRlJlVTlSUnpoeVlraHFWVVZvTldaNVNrZEZhbVJ4T0ZoSmNRcExRU3RTVDJSRVRsWlRX
      RUpCVUhwU2NYZFljVFF6WjNwTU5YRXpjSHBFY1dkck4xZHZURFZYVG5WNFRGWlVkVkpqY21GV1VG
      aDVPV05PTjBsdFpGZEZDbk4xTHpFMVpTdEVaVTgxUm5oQ2RuZEVSbU5sYTFsMU9FWktiSFJ1VFVs
      a1ZVZElSVGxXUlVvelVGWlJNM1JrZURWSVZXRTBXSFJGT1hsTFRXTk9RemdLVG1NdmRuZGtRVzQw
      WTBoU1YyRnRlbXhzTVZwUVN6RXJPVXQyVUVGRlFqWXhTMHBETTNSeVMxUnRaVkJUUzI1bVYwUXlV
      RzkzWWsweFUxWnBVR3hXWVFwNFRtWTBVVzVZVm5wSFUzaE9TelpNZG01Q1dHRXZWVVp4TjJGcVIw
      SmxTVk5oT1c1NVlqSlZPSFZCYWpCNGJYcDNXWHAxYWtoUWIzZFJkRlozTjFSeUNsbDJRVkJsYmpC
      NWFuUjFNMDAxSzJsbVNtdGxkSGRuV0d4dWRuaEVZMU5pT1RjemRGVTNkamxXZFdzd1RGSlVaa1Iw
      V1RodVREQjFObVJqYWpBd2FTOEtXVGRFYTFoWk1EVjBNa1JQV2tjeVRuZHVMemhoYUhGV1MybEVU
      Mkp0UzI5MFMxWXJOVzlOTVRZNWFEZGhlakY1TURFcllrSXZVbTEyY1habFNUWTBid280VUcxRVFY
      RnBVM1JhY3owS1BYcFNNemtLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit open tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for open EACCES for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for open EACCES for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for open EPERM for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for open EPERM for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - openat
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_openat,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - openat
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80754-5
    - DISA-STIG-RHEL-08-030430
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_openat
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeTg0ZG5jMU9FUXJhalZ3VGtGUmFXRTBVa0ZCYldwWlEw
      ZG9Ua1J4V1ROcWEwNU9iV0UyZGxSSFZESTFUbmw1VnpSeGN5OEtWalJuTlRsYU1qSnFOeko1ZG5s
      U2RUQnRSakZOYTB0WGQzVjBTMFJSZFdkbFMxQnRibUZUY2xneE4waDNhakJ3TWpCelVFMUhkak1y
      WkVwdU5XdGpVd293V2k5S1NtOWFXREpYVmtsTVYwWlljMjl0UTFsVFEyc3ZiazlGYWxoU1prMUJV
      VEpST1ZCM2JGZFZTR1Z3YUU1SmFVMDVVbkZVV0ZSU1lXRXpUbUZVQ2tGMGNVMVZSRzEwVWs1UU5W
      RlZaM05YY1ZFeldrWnRVQzloUm1ObWR6ZERZbG8zVm5GamIyZFVOazVoV2psa2NYVktTVzk1WkZw
      bmRWcHhhSE5HYzI0S1RHZ3JSa2RWYUZFME4wNHlVVzRyYTJKWVVFTXhUemQ1WkU4eGVITXhUMkY0
      WkRKYVdUZE5jM2N3UjBKcloyUjNUMVZRUzB4aWNHUTNRVVF2WWk5dVVBcG5UekJrUTNsNlRrUlZi
      M2xoYTFGNFdITkNVMVJLYUhCd2RHRklVVU5WYUVaR1NtUlFVVUp2ZDNkU01IRkNiMDE0ZUhWRGRF
      czJTemR3TW5WeVFVaFpDbFUyVURGUFkyMXBOSEJNUVVGM1kwRjJkVEZSZGpCUlNEZExURUkwSzJZ
      NU1uUmtVREEzU0hsVGEwZFlibkJUZEdGWE1HMVRkRlozVjBvcllWRnNiVThLTUc5UlRIUkNiMU5M
      UkZwbkwyTXdVbmxGYkZwd1QyY3dXR0k1V1hRNVlrOWlWbFpWT0hkSVJ6QTFSRlZ0ZG5sMGNHTXdW
      alZ0Vm5wSmVHNU5SMFlyV2dwUFNFSkRaRVZtT1dkU1dWQlBOMkZRTUhCSk5FVkdVRFEwV1hVNE1E
      ZEpVMkZzTjNsdWF6WnpTMHhtTlhoTk5rWTJhM1JoYWtGQk5XRkRPWEU0WTFBMENqQkhiekExZFZO
      TVpIVTRSWGhFVVVweloyOWhZbkp0UmtKVFZVOTBVa2xWUWk5Q00xUkdXVU5TUzNZeWFWTTRObUYy
      ZG0wNWVWUm9PRGRTY0dadU5ETUtSMGxUTmtZclQycG9TSFo1YmxGM2MwTlRPSFJLUmpNemFYQTFX
      bXNyTDNGa1kyUkpNbTByT1ZZeFJVUkxjRnBFVUdGU05rUmplRWxZZG1GU2RqSnlZZ3AyVkc5eFRX
      NTRRV1pWWnowS1BVb3lhV1VLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit openat tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for openat EACCES for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for openat EACCES for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for openat EPERM for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for openat EPERM for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - openat
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of openat in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - open_by_handle_at
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_open_by_handle_at,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - open_by_handle_at
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80755-2
    - DISA-STIG-RHEL-08-030450
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_open_by_handle_at
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExaeTl6ZG5jMU9FUXJhalZ3VGtGUmFGUjRRUzh2Wm1admVH
      VkVaVkJpYkdOT09YTlVVR1oyUkZsNVJUUlhhRmM0WmxabFRtd0tkMUJwVDFBMmJ6QkdNSGxvUnpr
      MU1tMXBkamxCZUUxNmQyb3ZkSGxuTTNOelpFOU1ZbmxDYUVzeE5sVktkWE5ET1VKa2N6RkJUbWxo
      WVhweWEyVXdVZ3BvTDJaVFdGWk5iMlo2YmpOdGMyUlJXbVJLUzB0MldWZGlLMnA2V0Rkb1lqRTJT
      RkV4V1ZvemFVTTBaVk5STDJscVFqaEJNbXMzV0VsWlZFNUpZMDF5Q2tkVVJHUjJTUzlFY3pnellu
      UkdNVWxtWmpGWldtRnlXRlZRY1VsNFRsWm9RMUl4YmpOT2FISmxhVkF6TUdoYVQycERkM0ZhUXpa
      amRqVXJlSEFyY21JS0syUjRjUzh5VFc5TVFsZElTM0JxYVRKV2NtRmpNbXBKUzFZMFdIcHhWMkZ6
      T1c5M1NGVXpTalEyY0hoWGVFRlJkV052TTA1elUzZFdOMkZJUjNRMlJBcERSMFp0V1VaaFpHTlpN
      a051UlVWNWNGRm9kbVl5VVZNd1pXWTBSV3hoVEhkS0wxTndXR2cyYmxWSVlYRkJNMVJ0Y3k5MFIz
      QXdTbTloVm5RMll6WXdDamRQUlVOdGVFcFBXVzF3VmxNd1FWSmtkVGsxTjFCbk1qQXphbHBEVkZG
      WE9YaFFkR2MwVVVoRWJGRm9aelpzWXk5MmQyeFVWVkJhWjFFMVdtOXpUMGtLU0V0c1JWRnljM0ZF
      V1hGd2FXOUxZblE0TVUxWFVtRnhlSFZuU1dOcE9UVXlOeTl6WlRWTlZ5dEhlbXA1V21oUVJGQnJR
      a3cwTDNORE9VSlpia2RoWmdwNllqYzBaREJzTjFneVMwbERiVXhTTWtsck0xUlZVMGRoU0ZrNFVX
      eFNUbWRKZGtOQ0wzbE1NM1p3YUV3dldtWmhiVWRaUVhNclpIWTRVemh2Y2k5akNuSklhVkZJTlZK
      SGRsZzBVVkV5YzB0NVdVZGxXV0ZzWTNndmVrNUJNa2x2V0VsT2NVaGpUVE0yUkRkQ2FHWnNjbXg0
      WldRMmVISjVka0p0Um1KVFYwTUtUVVJuVVhCc1luSmxOREoyZERGdmQyTmxXbVZVVFdvMVprZFFP
      SGhGYkVKalVHWnFObFJ6YkZCNFJtaGxNMk16YURSeGFYWndiMEk0U0cxRUwzZ3lZd3BZVnl0blMw
      SkJTRTQzZHowS1BVZ3hSR0lLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit open_by_handle_at tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for open_by_handle_at EACCES for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for open_by_handle_at EACCES for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for open_by_handle_at EPERM for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for open_by_handle_at EPERM for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - open_by_handle_at
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of open_by_handle_at in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Unsuccessful Access Attempts to Files - truncate
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_unsuccessful_file_modification_truncate,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Unsuccessful Access Attempts to Files - truncate
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80756-0
    - DISA-STIG-RHEL-08-030420
    - NIST-800-171-3.1.7
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.1
    - PCI-DSS-Req-10.2.4
    - audit_rules_unsuccessful_file_modification_truncate
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUZOZG5jMU9FUXJhalZ3VGtGUlowZHNaeTh2VW04emNH
      UkNWbUp4WlhKV1pVSnpXV2RIVlRKQ1prcHRSeXR0TW5WS1RXUUtPVTVwVlUxMlMxSmxaMUEwYkU5
      eGVrOHhUSFpxZEZaeU1GaEpNSHB6ZWxnMVVuUjBWbkVyT0VoSE9XTlBjVlo2VDBkRE9GWXhORmt2
      T0hwQmRtcFZlQXBsS3pWSVIzRkVjMk5vZFdoT1NXOVJLMHB6VVV4VVJIbEtVVkkzWm5KaWJ6Y3ZV
      VXNyUkRWaWFFUkVTbmRWVlZZd1VGQjNaRU5NZEdSa1RTOW9UVE5TQ2xKMmFIZHViMmwwWWpjcmJr
      MDROMGhDYlVwRVZHeG9lR2RQUnpNM2IyTmtZblJpYUc1MVYzSjBiblpZWVZkTlZEZFVVbmhrU2tK
      cVdtNUZjREZZY1RFS1EyNVhSRVZqYjJKd2RGbHVNVFZNV21Sc1UzVnNiVGh5TWpCSU5HTjZPVXht
      ZFhObVYwVnNUV3cwZFVWd1duUjNORmRSY0dGVlV6TnlkMmhsVkV0WFF3cEljVFphWlRGWlJVWXlT
      Vmx0ZHk5bmNHcFVRbEpKUVZKMk1VVkVaMlpyTkdSVFNVTjZlVlJRUzBGNFRtMUthMk1yV0N0R1Jr
      NTBiWGxMTXk5TFdHdzRDbkZKWm1JNVpIWnVUSE5zWlVSTE5GUjJWRTFOY25WV00yNURiMjR2U25W
      VE4wSjZabEF6VW01SGEzZERaMFV4UjNGTUt6TjBaa3hLT1RoVmMyWjNLMFFLTVhOUVdsbEZURmwz
      VW1NMlpHUmtkVlZTVG1OQ2JUUXdXamRzYzFFeFpISjNieTg0TkVJMlRVc3laRWRtVWtSMldsTkpS
      U3QzTkZkTmJVVnFZVTFWTndwdWVtc3hlaTlOT0hkV1pWbHBkREZRWlU1S1VYaENRazV0TWxSVVpt
      dERPRmRYVG5CVVVXczBhRkJSTm05bFdtUnBXSFJpTURWWlVsQnhTRTFPTDJNdkNrWkdTVmxTTWxC
      bVFtTnFhM0Z6WW5rd2NGTTRZazVISzBFNVVUa3lRWFJvTUdKalEyRnFjbUp2WTBKRFVHOWFUMHBu
      YTA5NGFUUTJWeXRMU1haNGJXVUtWa05FUjI4NVdqRkxibkZwV2xGRU9WQkdXRFYzVlcxWFJrcE1l
      akp3ZW1aRk5VTlNaM0Z3VURaV1oxTnhhRU0xTlZGelJGTXhSbVY1UTNVeWRVZzNNUXB0V21zeU9V
      OVVOMjFKYnowS1BXRlJTbFFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit truncate tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for truncate EACCES for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for truncate EACCES for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EACCES -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EACCES -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"

    - name: Perform remediation of Audit rules for truncate EPERM for x86 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b32(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b32)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b32 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Perform remediation of Audit rules for truncate EPERM for x86_64 platform
      block:

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/rules.d/
          find:
            paths: /etc/audit/rules.d
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: '*.rules'
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Reset syscalls found per file
          set_fact:
            syscalls_per_file: {}
            found_paths_dict: {}

        - name: Declare syscalls found per file
          set_fact: syscalls_per_file="{{ syscalls_per_file | combine( {item.files[0].path :[item.item] + syscalls_per_file.get(item.files[0].path, []) } ) }}"
          loop: '{{ find_command.results | selectattr(''matched'') | list }}'

        - name: Declare files where syscalls were found
          set_fact: found_paths="{{ find_command.results | map(attribute='files') | flatten | map(attribute='path') | list }}"

        - name: Count occurrences of syscalls in paths
          set_fact: found_paths_dict="{{ found_paths_dict | combine({ item:1+found_paths_dict.get(item, 0) }) }}"
          loop: '{{ find_command.results | map(attribute=''files'') | flatten | map(attribute=''path'') | list }}'

        - name: Get path with most syscalls
          set_fact: audit_file="{{ (found_paths_dict | dict2items() | sort(attribute='value') | last).key }}"
          when: found_paths | length >= 1

        - name: No file with syscall found, set path to /etc/audit/rules.d/access.rules
          set_fact: audit_file="/etc/audit/rules.d/access.rules"
          when: found_paths | length == 0

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_per_file[audit_file] | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0

        - name: Declare list of syscalls
          set_fact:
            syscalls:
              - truncate
            syscall_grouping:
              - creat
              - ftruncate
              - truncate
              - open
              - openat
              - open_by_handle_at

        - name: Check existence of truncate in /etc/audit/audit.rules
          find:
            paths: /etc/audit
            contains: -a always,exit -F arch=b64(( -S |,)\w+)*(( -S |,){{ item }})+(( -S |,)\w+)* -F exit=-EPERM -F auid>=1000 -F auid!=unset (-k\s+|-F\s+key=)\S+\s*$
            patterns: audit.rules
          register: find_command
          loop: '{{ (syscall_grouping + syscalls) | unique }}'

        - name: Set path to /etc/audit/audit.rules
          set_fact: audit_file="/etc/audit/audit.rules"

        - name: Declare found syscalls
          set_fact: syscalls_found="{{ find_command.results | selectattr('matched') | map(attribute='item') | list }}"

        - name: Declare missing syscalls
          set_fact: missing_syscalls="{{ syscalls | difference(syscalls_found) }}"

        - name: Replace the audit rule in {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            regexp: (-a always,exit -F arch=b64)(?=.*(?:(?:-S |,)(?:{{ syscalls_found | join("|") }}))\b)((?:( -S |,)\w+)+)( -F exit=-EPERM -F auid>=1000 -F auid!=unset (?:-k |-F key=)\w+)
            line: \1\2\3{{ missing_syscalls | join("\3") }}\4
            backrefs: true
            state: present
          when: syscalls_found | length > 0 and missing_syscalls | length > 0

        - name: Add the audit rule to {{ audit_file }}
          lineinfile:
            path: '{{ audit_file }}'
            line: -a always,exit -F arch=b64 -S {{ syscalls | join(',') }} -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=access
            create: true
            mode: o-rwx
            state: present
          when: syscalls_found | length == 0
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - audit_arch == "b64"


# Record Events that Modify User&#x2F;Group Information - &#x2F;etc&#x2F;group
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_group,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/group
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80758-6
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030170
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - audit_rules_usergroup_modification_group
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUZOZG5jMU9FUXJhalZ3VGtGUmFFNUNVUzh2Vkd4dmVs
      YzJhVTR2UVRWNldISlBTbWR1Y25nd1FqUnFiRkZPZGxwWlNYa0tZMUZCU1V0cldrTm9aamx5ZUVo
      VE1teEpOMk5YZFhoVlQwbElOM0V4ZFRCdU9XaFVWMHhvYW1Kd2NrTlFSakI2VFdkTFVsVlRXamxy
      Vms5VE5YSnpkd3BtYW5rNU0yaHllVXBJVFRJd2JGRXJka0pGY25BeWVFdHBlVGRaTmt0aVRtaHRM
      MWxVUjFGcVNEUjNNbVZuUzJrMk9DOHJWRlphTDFWS2EyVjNka3hzQ21GNE1HWm5iVFprUWl0WFZE
      VldUM05qVkZwRGNHbEpSMFV6YzJGWmNFUjRVbnBHY3pWc2QyRTNaemwzVlcxNE5EbHViMlZxVEdW
      R1ptVlpTbTA1UW5VS1dsTTBUVTlJZWpOUmFVMU1Oa2gzU2twRmNIWktMek5TWkZjNVZUZE5RV1Jo
      VTBodWFtdzRWV3hRU1RSR09IQm9OSG8xUVdKWE0wZFRkMHBOVDBKc1pBcEJLemxwYzFKeEwxWmtV
      M2czVkVKSWVsVkdUMnBDYTJoS1dtOWpTMUJOWVRkWldEUkVNREZqVEhkdmN6SlFPR2RhYlZKSVpG
      aFdhM1VyWTJGUUswVndDaXRGVmpadWQxWlVWalV5TVRCQlN6Qm5ZVVpxUkVweFJETjVWRmRzVG1S
      clFWbFlORGQwVTFjM01YY3lTSFJYZUUxTk1ETkNiRVF4TUhWa1FraFZObTRLU1U1RmVWQjVNRlJh
      Y2t0MFNEUXlWMHRwZFVOdWNqVTBlRk42YkVkc09IaGFkV1ZHSzNaS1oyeG9Ta3hyWm1kTGJGRmhh
      MjUxTHpObEwydE5kWFY1Y0Fvd1pIVlVlV2hoU3psV1JHWlZiV0Z0T1RJMlQzWm9SMVIyVDBSV1Jq
      QnpVV3BuT1habVVpdE9PSFV4VGtORFUzSlJURk15ZUhGc1pVaFBlRVF3WkVFM0NrTTFaREJ1UjIw
      MlNGRllWVlZ6VTNjdlYxcG1WRzlSYmxwR1YycGhVbUZQZDIxRVluYzNjV28wWkVkYVEySkVhbWh2
      YWtkV2RYazJlblI2UmsxalRWa0tRbFZtTVVrNE5VaHFjRXBXTlhCRlQxVlNla2hMWWpCdFNIUkRh
      VTVJYkdGMk5sZG1UbFJGYldVeVpVcERja1JqVFVnME1XOVZPRUl5YVdkQ2NsSnlPUXBZZUhsa1RI
      ZFNVbFJqUlQwS1BVeGxSV29LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit group tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_group
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_group.matched is defined and find_group.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_group.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_group.matched is defined and find_group.matched > 0

    - name: Inserts/replaces the group rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/group -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces the group rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/group -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record Events that Modify User&#x2F;Group Information - &#x2F;etc&#x2F;gshadow
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_gshadow,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/gshadow
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80759-4
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030160
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - audit_rules_usergroup_modification_gshadow
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUZqZG5jMU9FUXJhalZ3VGtGUmFtd3JRa0ZCYmtwcmRV
      ZDVUR0phSzNoR1VGZzNjMnRPU0VVclVVbGthbUpXYlc5MldXWUtObXRYWmpWdFEybDZLMk40UVdz
      MGFVUnViVzFUSzFCUVFVZDJaV3RNZWtseVNtbHFjRE5xTUc1RVNGVkRXa3RaZFhGUEwzcHlVMmxP
      V0hwQk5tMUZkd3BrUTFGbFMwbEpObkY2ZUZSc1ZITlZTakJoUTBJeU1tUnFWM1FySzJKbGMwZHpR
      VmhLVERGc05pOU1OVkJVYlV0SmNWQkRWR2c0ZG5KT2FsQmllVFJ2Q2tzNFF5c3JXVm93WjFGc1R6
      aEJabFZvUVVjMlNsQnZWMWhVWlVadFV6WXdVVGtyVldsTk5GY3hlSEZoUVZndk16Qk5SVU5tU1Vo
      Vk16WnVlVkZ6WTFnS09YZDVMMkZoZWxNNUwzVmpUemhEU2tGbmIwaFpSRE5wYWpGRVl6ZFpTa1o0
      ZEdwS09VMWpTbE5MTmk5M2QyMHhlV3MwTXpkWkswTkdXR2M1ZEhsYVZncFBha0ZaSzNKc2ExTlVV
      R1psTkVkUGF6SndNeXRSY2tSeE56WktibkZQTVZKNVpsRTFkM2h0TTNsVVIzcExObXAzZUN0RFNV
      dGtWV3QwZW1NdlJXMDBDbXRCUVZSd2QxbDNlRmQ1ZEZkMGRteDBNMnhxUlRWVWVWWnJVSGRHZDNv
      d2NWZFlXRGh3VkhKNWIyUjNhMDF1TVc1UmNXcExaa056ZVdWNVRYWXZXbFFLVVhGblpITXZjRlky
      ZHpWMVFWazNTM1FyTjJOdGFIbHNaVlZOY0ZveVFrbHdlbVJ1VW1NemNXcHNSVTVWYlc1SWRESkJk
      R2s0UmtkMVQybDFWWFp5WVFwRk9WaEtjWGcxV0hwMU5sRTVTMFJMVFU1RFp6RjBUMmx3YVVaNVNH
      ZDNibmRvTkZsa2NEWkllakZ5YVVRd1UwMXVlWEpPZVdZeVNVUnNOVll6VlVsTUNuRmxkRVZyVFRV
      d1EwUkdNM2RZYjIxdE5qRnJVMGN5Y0ZCM05HdzFlWFJhUzBaSksxZE9SVFJQUkdkeU5YRnhhMDF3
      ZEdSSWFtaEVSVWROU1dGcE4yWUtlVzlLVlV4UUsyaFZSRGgxWjJSU1VHWldlbVJ3Wkc5bVVpOWFk
      RWx6WXpGMVlUTklZMWhhY2k4M1dtTTVRbkJsTVdoMVlqaFBXa1E0VFhsc1FUazJiQXBTVTJWWldr
      dHpZVEJ3WXowS1BXbzJWRU1LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit gshadow tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_gshadow
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_gshadow.matched is defined and find_gshadow.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_gshadow.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_gshadow.matched is defined and find_gshadow.matched > 0

    - name: Inserts/replaces the gshadow rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces the gshadow rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/gshadow -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record Events that Modify User&#x2F;Group Information - &#x2F;etc&#x2F;security&#x2F;opasswd
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_opasswd,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/security/opasswd
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80760-2
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030140
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - audit_rules_usergroup_modification_opasswd
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUZqZG5jMU9FUXJhalZ3VGtGUmFWQnZkeThyVERkc1pV
      eEJiaTk2T0ZRNVVXVk9PRXRTWlVoSWRYQXpiR1ppUWs1VE9XUUtkaTlKYWpoM05qRTRaVFJJV1M5
      eU5sVkRSMjR2UVZJckszWnpWbUpxYTNBNVJWZ3hXVGxtYWtGaWMxTXdjREJ0TDJkRVNtUjVaM1ow
      TjJOWGRWaG5Vd3B0UzFCbVNHZHRjVVV4TlU1cGNrNUxURWhqVFd0S2MzWjNWamc1TVhCU1pFcHhN
      MmhCZEc1WE56RklUR3d6TVU5NGRtOVVZbEZYZEZsbEwweDJXVEpZQ2xGVWNHdHRWMmhPY1V4bFow
      WnlTMUJRTkhKMU1tTkJWM2xpTW1Jd01Ha3JWV0pHV0VJNGJsaDVORmg2VFdwMlJEUnpPRVJOVlZN
      NU5YbFBSVmMyUlVrS05uZEdSM281ZFVFeU5WWkZWSFZEVHpWMFFsWkROVUkxZFZNeVIxbEpPREJH
      WmxkeWVUQTNVSGc0VGswMFRIZGtkbVUzVEVWWGRHbE9jMlJLVkZGdGVRcGxNblUyVnpZeFdERnJU
      R05LUVRsSllrdzFhMDUzYTFaR2QwdG1VQ3Q0V1dsamRtaGxhMG96VGlzeU9HOXBNbUZQWmxOemVV
      MVRSWFYwUVdOQlUyNVZDbkZzTW5ObGVuVXhZalZwWlRONGQxUnNSVmQ0UTNOaGNXeHpVa3d4UkVO
      elltd3ZXRE5hV2pOdU1FVXhaMjFpUlM5TFVuTnpSVUpPVmxBeGF6SnJPV1VLVDNoMmVFUlpXbE55
      UlUxdVFsSjNabVkxV1VaV1drVlhSbmxHV0d4NE1YaFhXa2hqYjJJeVJFSTFTMjV4ZG1zNGF5dDFU
      SE55VDB4UGIyMVdZM1J0THdwVVVIZHlZbm95YUVkRFpucFpka2d2VkZGblRFTndZMGxuTURKcGEx
      RTRWVkZ2VFVKYVIwcDZUa2x3WVhOWE1Dc3hXVXRhWWpGSWJqSlllRVJUVDNOaENuVTJkakpOUVdo
      ck5GcG1halF6UzFCYVNWazFhbmw0YkZCbE9FVjVkWEZKT1dkclZFWnFTR2RxVDFSdk5td3hkV2hZ
      VjFRNUwwdDJkMFp5T0c1T09HOEtlRlZZZGtGblR5dEJUMmc0ZDNsT1kyTllVM2x0UVdJeU5pdEhS
      bWxFYWtNNFp6UjZiRU5wT1c1WldHSm5RVGhMTW14a1QxUXhNVVJDUkhSMGFXZFlXZ3BTYmxCb2FF
      d3JTR2RUTkQwS1BWTk9hbm9LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit opasswd tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_opasswd
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_opasswd.matched is defined and find_opasswd.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_opasswd.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_opasswd.matched is defined and find_opasswd.matched > 0

    - name: Inserts/replaces the opasswd rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces the opasswd rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record Events that Modify User&#x2F;Group Information - &#x2F;etc&#x2F;passwd
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_passwd,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/passwd
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80761-0
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030150
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - audit_rules_usergroup_modification_passwd
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUZqZG5jMU9FUXJhalZ3VGtGUmFHZDRaeTgxUVZwek1H
      YzNTMHRJY1RaeGMxUmFZMHgyVjNwdFFXeEJMMUZDV1hremFTOEtjMU54VEV0NlkyaFJNRnAxV2ta
      VFRrVnRhbGhPUlVwS09YTjBOMjVIV0VRek5DdDBhblZpZDJOQmNYWnRMeTlsYjFkdU4wbDZRVEI2
      VVRsM1lsSlJhQW94VWtkRVRHTlRaaXN2UkVSYU9UVnJRMWRuZG5WNk0zVjNRbXBIZVU4M1JXbFBO
      MEZtVHpCNU56RkJSR1pDYkRsT1pIZHRTemxVV1dOR1MzVnZRVkJYQ25ZeWRqazJlR001V0c1NGVF
      dGpiVFZtYUdRMmVUSkVkVm95TVdSNWVFdHdWMlpZUnpKNlJEWnZPV0pyWldobmJFd3lZbUYzVmpG
      YVpsTkpZMnBvVFdrS1JXYzBValkzYkZFek9UaFlTR3hNUmxoNFNWWXljelZMVTNoalZsVlhPSFJM
      WkVzM09FeHJRbE1yTDJ0Wk1HWjNOamhQWlVwV1ZFWkZSRlUxU0UxalJncFNUblI0Y1ZOUU9FeFZk
      RmgzTDFSa1ZGVkxNMHRoYlhkbVJtWTRaWFpYYms1VVVuRkpXRUU0UzA5a1pYQm1halExVUdWdWJ6
      Wm1RMmMwTkdoSGNHNTFDbmxJU2taa2RuQm1SVXQzZEhWdE1VOVZXR000WnpkSFdqZ3ZORnBrUlVo
      Q1JFSllTV2w0V0hneVQzbExia1ZYYXpGT1RsQm9aV3RJZW0xUk1sRkhhVWNLZVVsTWFHdFRkU3Rh
      YjNSUmNYSXZZVTVZU0hCSWNsVk9kREpSU0dNM1ZYQndOVk5EUm1kVlUzbHBZamhHTWl0Q1YwRnlL
      M1owZERSdGNUTkJVVUZsV2dwRksyMXVkRnBVYURGcFFtSm9UblowZUZKd1ZtdEpOVUV3VG01M1pH
      UjRZbGgwUWpGS09VTlhOVmRQYVZNclpIQjJaRmt4TkUxR1EyRjJZV00zYkdGd0NrcERhWGh4VjFJ
      NFUyMUpUVmh3VUVvNVVsaHJTMUpaWkZObGMwb3hRWEJxT0ZoQ2JGUkNSa05sYkZabFRVc3pZelZC
      WlZWQ05XTmFMMGRyUkdWdllsUUtZVnBGZGtSMlRraFlTM0ZDUTNwaWJVaGlVblZvUmxnMmJ6ZEZM
      M2szV25aSllYTTRkM2RzZFdsdkswbFNOR28zVDNObmJVeDFkakJ5VEZwWmMxcFRkZ3BLZDFGc1J6
      bDJaa1JNV1QwS1BWaEVjeklLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit passwd tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_passwd
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_passwd.matched is defined and find_passwd.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_passwd.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_passwd.matched is defined and find_passwd.matched > 0

    - name: Inserts/replaces the passwd rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces the passwd rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/passwd -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Record Events that Modify User&#x2F;Group Information - &#x2F;etc&#x2F;shadow
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_audit_rules_usergroup_modification_shadow,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = true
# strategy = restrict
# complexity = low
# disruption = low
- name: Record Events that Modify User/Group Information - /etc/shadow
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80762-8
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030130
    - NIST-800-171-3.1.7
    - NIST-800-53-AC-2(4)
    - NIST-800-53-AC-6(9)
    - NIST-800-53-AU-12(c)
    - NIST-800-53-AU-2(d)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.5
    - audit_rules_usergroup_modification_shadow
    - low_complexity
    - low_disruption
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUZ6ZG5jMU9FUXJhalZ3VGtGUmFWRk5aeTh2VjFOWVVY
      aG9PRFF6VlROaWIwOUpXWFZ3UjNkUVdFZ3JUMGhxVFRRM2NuSUtTR0k0WW5wbVdXTkNaMFJ1ZGto
      M1RGbGFTRTkxUTFGeEwyY3pTa3hIVFc4eVlXWmlORlJST1hKeFlWSnVOVE16ZVVoclltaG5NMjF2
      UW1seFluVjFVUXBsZVVwWFJ6STBabnBITTI5RU1YUmlhMXBrUTBwRlltRm5ORVZzVURONVJ6Sklh
      WEp4TldsUWQxRkplRlJ1T0M5SVJub3dhMG8wU25SdWJqVlBTbU16Q25KTWRVcDFlbU5KUlZsclZE
      Wk1lRXhYZG1Wdk5TOXNUamhqVDBaVmJHbFZha1JhTVUxR1R6ZHJMMnAxWjNobVVFSnZUbVpuT0hC
      ck5tWnNkMlYzYTFvS2JIRktRV0pOTTJ4blZFUlVXR1ZGY1ZkUlZrWmtNMVZLWnpoV2F6WlpPWEY1
      TDFKblJFcG5RMFZ3VldsdGJFVkJXSGhqYjNWT1IyaE1RWGxQVVRWeFVRcHdSWFpPVEM5a01FNWlT
      RVJYU1U1dVRHSjVhekJuWTJ4WE9IQjNhRFJuUzFSRmRHUnRTMUEyUTFSdWNTOVlSazR2ZDA5WFZt
      RTRWRmxVVFhJd1YzWmpDak5zUjFaWFZVNWphR3RzWmt4MGRrUnRZU3RxUjJObGMwNTJZblJUUTFa
      aWIyd3hlRkJJYmpjMEt6aE1ZVUp2Y0ZBM05FTlRhM2h6WVRCRmVHaGxaM0VLUVdWNmJpOXZLMjE1
      WW1GV2RtcEVNRXNyY3pCUWFrMUpTSFZ3WlVVMWNEQmpkMEZXUWtsalJVZEVVSEpSTlZKUVRtUlBL
      MFExV0RJME4yeDFhM0pMVFFwT1JHbHhjRzFCUW5KVE1sSXpWVUlyV0hKaVdHdHdUemRKTDBJMFVV
      cHdUVlF3YWxabU4wMUZSRkZZZFZkRE5GTnJhRW9yZWxZNE4yeHNkVTFyTVdzMUNuWnNiR1l5VG01
      c2FWaHVaRUUwYm5WU2RDdFBTblpSY2tsVmJtdzVRbGw0YkRaamRqVk9WMjFFT0hneFdrOVFUMlpy
      T0RVM1VpOUthbVk1T1UwMWIyc0tValpNVEZCVWJuTkJiRFZ4WkdObVRUUnphbFJITnpaTldqRjBX
      R3BpUkZSbVIzSkdWVXMyVFN0WFJITlhVM1F6U0RKbU0xbFFRMmhMZDNaeFdWWTBNZ3BEWVVoUFlr
      aGtZMmx4UlQwS1BVWmtTbVVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set architecture for audit shadow tasks
      set_fact:
        audit_arch: b{{ ansible_architecture | regex_replace('.*(\d\d$)','\1') }}
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Search /etc/audit/rules.d for other user/group modification audit rules
      find:
        paths: /etc/audit/rules.d
        recurse: false
        contains: -k audit_rules_usergroup_modification$
        patterns: '*.rules'
      register: find_shadow
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: If existing user/group modification ruleset not found, use /etc/audit/rules.d/privileged.rules as the recipient for the rule
      set_fact:
        all_files:
          - /etc/audit/rules.d/privileged.rules
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_shadow.matched is defined and find_shadow.matched == 0

    - name: Use matched file as the recipient for the rule
      set_fact:
        all_files:
          - '{{ find_shadow.files | map(attribute=''path'') | list | first }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - find_shadow.matched is defined and find_shadow.matched > 0

    - name: Inserts/replaces the shadow rule in rules.d when on x86
      lineinfile:
        path: '{{ all_files[0] }}'
        line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Inserts/replaces the shadow rule in /etc/audit/audit.rules
      lineinfile:
        line: -w /etc/shadow -p wa -k audit_rules_usergroup_modification
        state: present
        dest: /etc/audit/audit.rules
        create: true
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Configure opensc Smart Card Drivers
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_configure_opensc_card_drivers,fix)
# Version: undefined
# platform = Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8,multi_platform_fedora,multi_platform_rhv,multi_platform_ol
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Configure opensc Smart Card Drivers
  hosts: 'tower.lab'
  become: true
  vars:
    var_smartcard_drivers: cac
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRUp6ZG5jMU9FUXJhalZ3VGtGUmFEZGhaeTgzUWs5NVlY
      aHJWblZUWm00NWJVTjBWWEpXT0ZaSGFHRXdlRTlYUlZGSlJIVUtOVVZWU1RsbVkweGxPRFJ2WTNW
      SWNtSXpURGgwUVc1SlMwbzFVMEZ2ZGpKTk4xaFpaVkkwYUROemJtcHlSU3RYVkZsT09ERkZlRk0y
      UzJsU1FubGhNQXBXYnk5clJIWk1jalZpYTFsaloxZHhSak5VVmpSNWVsUkJPVnAwTkhBeWREVTRX
      RmxXU2pCR2RXcFJhMFZGTW5WelZtUXJWVzUzY2l0alVrcFdRMnQzQ2pWSWFXaFFaM0Z3YVROR1FY
      bzRhRGxTZVdaemJuUmtUMjlwVFhsdGFVZzRZVzFrTDNvclZrNTVaa05yYWxWVVZYaFFla0o2YlVa
      UFV5OXlUMlZwTjFVS1NXZ3pRa0pyY0ZwRlJWSjBhRmsyTmpKMmJXVTFhM0l2ZG1GaldFd3hhMkpa
      U2tweE5qVlRjQ3R6ZW1GRldWSmFPSFJHT1RaRlRWZHNTRVZqTldVMlJncGlSblZhUVhOaE0yeDVT
      RkZaU1VwSmNESkthbXBGZGtSd01tZDFXR05rTTJZNGFYSnBRekJLWVVGcmRYRnNiV3d2T1dkVFdF
      MWFMelF2WTBGalRIY3pDa05xYkZSMVZFZ3lXRGg0ZDIxc2FIQkRhbFpvYlhwRk5XMUxVbkZrZUVk
      WVJqUmhkM2xRTnprMFNtcEVhV3hETDBWR01YaHpVREkzVkd0TlIyaGtPVEVLTDA5cGVHdzNUSE5w
      UVRVeWRUUjZORTVTYUhaTGRIcHdSVGMxWkRObWFtOHhhMnhETmxFMFJYVmlkWG94TkhRNE5UTXpO
      VmN2TTJ4NFZVMVBVWFZOTXdwQ1pYcExOMXBDY0N0WmMyeFlRWFZvY1hoTlIwWlRNV1ozU2xCM1JX
      aExVV1l6V0RsSVJUVkpRVFU0ZDJad1UyeHlUVk0yY0dKdmRsbHVTMFZVZDI0ekNqRklORVV4Y2xo
      WFIyNWliVlpZTVhWU2RrOWhZV0o2YTFFMVdUQjBORGhrVjFOcWNXdExNVUpWUzNob2MwbFlUa3g1
      VUc1SE0wTnFWR3BKZUhOV2JWQUtPRUZEVkZFeE0yOWpkMUJtUjFsb1RIcDJOalExYzBWVkwyTkRS
      a2M0ZVdGTE16bHJaVU5tVEdWTVlubFRTbmxzZWpob2FXbExiRTlHVDNCUFlqY3JlQXB1WjIxa1Z5
      dENWM2xHYXowS1BVSXhOMDhLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80766-9
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-2(1)
    - NIST-800-53-IA-2(11)
    - NIST-800-53-IA-2(2)
    - NIST-800-53-IA-2(3)
    - NIST-800-53-IA-2(4)
    - NIST-800-53-IA-2(6)
    - NIST-800-53-IA-2(7)
    - PCI-DSS-Req-8.3
    - configure_opensc_card_drivers
    - configure_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  tasks:

    - name: Check existence of opensc conf
      stat:
        path: /etc/opensc-{{ ansible_architecture }}.conf
      register: opensc_conf_cd
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Configure smartcard driver block
      block:

        - name: Check if card_drivers is defined
          command: /usr/bin/opensc-tool -G app:default:card_drivers
          changed_when: false
          register: card_drivers

        - name: Configure opensc Smart Card Drivers
          command: |
            /usr/bin/opensc-tool -S app:default:card_drivers:{{ var_smartcard_drivers }}
          when:
            - card_drivers.stdout != var_smartcard_drivers
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - opensc_conf_cd.stat.exists


# Ensure PAM Displays Last Logon&#x2F;Access Notification
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_display_login_attempts,fix)
# Version: undefined
# platform = multi_platform_sle,Red Hat Virtualization 4,multi_platform_fedora,multi_platform_ol,multi_platform_rhel,multi_platform_wrlinux
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Ensure PAM Displays Last Logon/Access Notification
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80788-3
    - CJIS-5.5.2
    - DISA-STIG-RHEL-08-020340
    - NIST-800-53-AC-9(1)
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.2.4
    - configure_strategy
    - display_login_attempts
    - low_complexity
    - low_disruption
    - low_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRU5OZG5jMU9FUXJhalZ3VGtGUmFGQklRa0ZCYW1WTlVt
      RkxlVVpRVld0ekt6QllNblYwY205UGVHNTZja0pHYTNRM2FrVUtOVEpwS3pRMVprMWlkbE5WU21k
      SWFDdHZTWGwwU2psS1NEUjNiMWhvU1U1QlNGQlRTRU4xZUhkWlVrWlZlbGxpYUZkTFJtaHVkRUZY
      YTNSUlMwUlFaUXBQTlRGQ1p5OW5aV2wyZDJkWlJXbG1SMmRwVHpoMGQwbEdkME5tV0hjcmJsUjFN
      VTlxTVRGcWFrTnJlRUptY0cxalEwaERiRWhFYkhkamJHbDRVSE5LQ21oUVNuRnlOMlY1ZHpOSGVE
      TlViR2RMZHk5M05rRTFiMHhVYkRaTlVqVkRiMlJqVjFCYVQxSjVNamhsT0V0V00zZFBkMHRsVTBS
      NlZqSmpUMFZhV1NzS1ZUTTJRbTR2YUhaeFpqQlZWa3hhUzNkU1FVMDJjQ3RyTDIxNmFtSm1ZVTFV
      ZG5KWlMyd3libEphTmtSaVIwUkpabkExYUVwR1lXVlVSRXN2T1dselV3bzROV0p6U1hoNmVrUllh
      M05VY0dsa1JFTkhjVzlLYm1wc1RIUTJka0o1VGtvNFlYaFVMMDB3YzA1UlNHTmthV3hGT1RNelJT
      dFViamMzTVhaTlRXaHRDa2N3YjFSUU1qTkNVamN4Wm5aUFdIUmhhREZxVlVkVFNFczFhV3hxUnpa
      cVFrSmtWMmxQWkVzMVRuTlpTVUZJUVZGc1RWWm1kVkJ6VjNJMlNqWnFMM1FLU0RkellTOXljMjVs
      ZW5oSmFrRTNZV2RIYzFsRVFVRjVLeTlCT0hKeFEzaFpRMmhJV0hsNlFWUkVhVnBpYURod2FtWjZa
      SE5OVW5Ka2VFSjBZMFZNWndwTGRtODJVamRzYkhwV01GWjZkM05wTlU1NFRtMXhlRkkyY1ZSM2My
      dFBOVmt5VVc1V1IyVkVTVW9yU3psV1VuZHVaVWRwVTNGUVVTdENRMnB3ZURkVkNtMVJaV2t4VGtk
      bWNYZHBhSFJHTW5wRWIwcFRNakpDUTAwMEsxTlliM0JRV21NNE9YRTNWMjV2ZEhwMU9FZEJNWGRG
      VW5aM1RtOWxiRUo1ZDJFclMyVUtSMXB2VG13NEwzQXdTV00xZVRWaGF6ZDVNREJQYUZRd00wcHFN
      MlJwT0dwcmJXUm9OMDlSTm14cVkwUllNQzlKYkZremNETkNXVGt5YmpobksyWXhVd3BEUVRoUVdH
      cERNelpXV1QwS1BXcFpNRGtLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: Check if pam_lastlog.so is set
      lineinfile:
        path: /etc/pam.d/postlogin
        regexp: ^\s*(session)(\s+)[^\s]+(\s+)(pam_lastlog\.so)(\s+)(.*)
        state: absent
      check_mode: true
      changed_when: false
      register: pam_lastlog_exists
      when: '"pam" in ansible_facts.packages'

    - name: Make sure pam_lastlog.so control is required
      replace:
        path: /etc/pam.d/postlogin
        regexp: ^\s*(session)(\s+)[^\s]+(\s+)(pam_lastlog\.so)(\s+)(.*)
        replace: \1\2required\3\4\5\6
      register: control_update_result
      when: '"pam" in ansible_facts.packages'

    - name: Add control for pam_lastlog.so module
      lineinfile:
        path: /etc/pam.d/postlogin
        line: session required pam_lastlog.so showfailed
      when:
        - '"pam" in ansible_facts.packages'
        - not pam_lastlog_exists.found
      register: add_new_pam_lastlog_control_result

    - name: Add 'showfailed' arg to pam_lastlog.so module
      pamd:
        name: postlogin
        type: session
        control: required
        module_path: pam_lastlog.so
        module_arguments: showfailed
        state: args_present
      when:
        - '"pam" in ansible_facts.packages'
        - not add_new_pam_lastlog_control_result.changed

    - name: Remove 'silent' arg for pam_lastlog.so module
      pamd:
        name: postlogin
        type: session
        control: required
        module_path: pam_lastlog.so
        module_arguments: silent
        state: args_absent
      when:
        - '"pam" in ansible_facts.packages'
        - not add_new_pam_lastlog_control_result.changed


# Ensure Logrotate Runs Periodically
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_ensure_logrotate_activated,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Ensure Logrotate Runs Periodically
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80794-1
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-10.7
    - configure_strategy
    - ensure_logrotate_activated
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRU56ZG5jMU9FUXJhalZ3VGtGUmFHNDJaeTg1Um5CV1lU
      Z3habFp4TlhWRmFHNXJhMWN5VW1ocVowUkZRVmNyVVdvMlRuY0tWbWhYV1c1SVRYbHNaak52ZG1K
      TmNYcGxWV1F4SzJSTFRtVkpTMjlVZDJ0WmN5OUtkV04zTmxacU4zQXZTbWRPT0ROSGNtWnljMDQz
      VDFoTWNHbGhlUXBrTlVaNmRXVkhNV1I2VlU4d1ZYTTVaa05CYTFsblMwc3ljVGxWU0RaemNEZFlk
      RmhMUVhoVk5qaDJOSE5CVERsd1VtdGFibHB6U0ZKaE9HeEJha295Q2lzelMzVXhTRnBvU1V4WFJq
      UlpNWEpOWmpKaFlWSm9PRTVZT1VSb2FUUkJTVTgwYmxwbFNsSjZZMjUzVFZZNFVYSkdOamQzWWlz
      cmREQlFPRFpGYmtvS1QyeHhhRTVZTkZrd04yaDVRMDl5T0hjdmJsbzRlbkV3VVRSTWVXUlZaMFZ3
      VG5sWGQzQm9jbEl6UTB4QlJXOHhiMmhyYjFsNldGbFFaazAxT1haclZ3cE5RWFl5YkVoeFZUaFFM
      elZPWWtWMGRTdENhMWc1VGs5cWJWZHdiMnh4V1V4TlFqVnlSbTAyTXpaT04zQTRWMk53ZFdKNGMw
      VjBaRWxrYTNreE5HaEdDbFZHYzA5WldEazRTMVF2UVdGa2FIbDRabXBVYTBaRk5ubFVaVkZDVkVF
      d1VuQkpOWGhtZUcxRE5WQndURUU0WWxscFNpOHZTVVZzUzBabVltNXFSREFLTDNkellVUjFVSFpS
      YVhoUFowUnhiMW8yYkdKVlpITmFTVnBLVnk5VlRsVjFVbXBaU21OR2RVcHFhbUpoWlhwNWMweFBa
      aXNyUlRoVE0xRk5ObXRuTndvdmVVMDFhVU15TlVWR2NVeGthRnB1TkVFdlVYUXpaR0ZDZEd0bFZY
      STJRemxIZWpOUlQxWXpPRnBzY0ZGWWJrZDZRbFJOZGlzM2RqWjFZVFpZVnpOWkNrbHFRVTB2VTNG
      SFJuZDVhRVZRWkZvdmFWQnRkRFZ0VEdKVmRGVkZkazFRZDFNMFZXOU5UR1JMTjNsVVQzTmhaazlh
      VlU1S1dFdHZkekp5T0dOdVZITUtiRkJSWlhsMlFUQlhaRGhoU1VodlFtTktOVWxVY0RNeVRVSnZX
      RU5oZGxFdk0ybHRSeXRMWlRRemJTOWpXRXBEWTFSdGJsWmhaMFJKWkN0aVltNVVNUXBLUTBaSmN6
      SmFUVlZsVlQwS1BUbEZWa2NLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Configure daily log rotation in /etc/logrotate.conf
      lineinfile:
        create: true
        dest: /etc/logrotate.conf
        regexp: ^daily$
        line: daily
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Make sure daily log rotation setting is not overriden in /etc/logrotate.conf
      lineinfile:
        create: false
        dest: /etc/logrotate.conf
        regexp: ^[\s]*(weekly|monthly|yearly)$
        state: absent
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Configure cron.daily if not already
      block:

        - name: Add shebang
          lineinfile:
            path: /etc/cron.daily/logrotate
            line: '#!/bin/sh'
            insertbefore: BOF
            create: true

        - name: Add logrotate call
          lineinfile:
            path: /etc/cron.daily/logrotate
            line: /usr/sbin/logrotate /etc/logrotate.conf
            regexp: ^[\s]*/usr/sbin/logrotate[\s\S]*/etc/logrotate.conf$
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Force opensc To Use Defined Smart Card Driver
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_force_opensc_card_drivers,fix)
# Version: undefined
# platform = Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8,multi_platform_fedora,multi_platform_rhv,multi_platform_ol
# reboot = false
# strategy = configure
# complexity = low
# disruption = low
- name: Force opensc To Use Defined Smart Card Driver
  hosts: 'tower.lab'
  become: true
  vars:
    var_smartcard_drivers: cac
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVJ6ZG5jMU9FUXJhalZ3VGtGUmFHbHFkeTg0UkdSNVR6
      WlljVE5vWVdOVVpVRlpaVEJ6YmxWRmMxbzViV05yWmpkWGNUWUtkWE41ZFRkMWVqWlhNbkJEWlhO
      NFJWZzBabTFEYTBWWlF5OUdhSGxQWWtGS2NXZzNTSHAzUnl0UlpVaDZabVowZEUxeGFubFpURTlO
      UWxkcGVFMXhUd3BHUkROaGEySnJSV1I1VVhWck5UbHJPRmhuWm1WTmRIRlRkRlpGSzNsd1ZXMDVk
      RmhrWlUwMFQyTXpSbWxuT1dORFRtdEtTRTExT0M5UVRIZHhSRWhhQ2k5Rk5reHlVMWRrZWtFd1Rq
      UkROekpNV1VSc1RFdExORkJ0YkdNM1puZHBjVXRLYzNKNmVIWXlkM1JWZFM5UGRWZFVVSFpsY21K
      MFlWSjZUUzlEUzFZS2NGQmtVR3M0U0hCVVYyVnBTRWh5YkhkTVluRmxaV3hRVkVFelVHVnVXbEJQ
      VVdOcVMySldibkJrTW1wa2FFa3dTa1I0YTJrM1oySjRlVGQ0Y0hsREx3b3dSalpPVTBSc0swRmpN
      elZ2YlZGVmRVMUdTVUZaTDFOTlRqQkdlV0V6ZGtKcFIzaERXa3h5TUdNeGFXSkVjbk5PVDBGSE0y
      OTVUVXBQVXl0dGRVbEdDbUZoT0VkRVRXMWtUVXg1UmxoblpGaEJPRVY2UVcxbFpIVTBTbFJ3VlZr
      emFYRjNZVVFyZWt0emRrMHJLM2xaVkRoU1MwOWpNbEZ4ZERabU9ESkJjellLWm14eFRVWk5SRWx0
      VVV0SFVUTXdiMlpHZFcxc1owdDZVMmcxUkRaVVJHdFFjQ3RRTjAxd2MyNTFORVZ4ZGtRd2VVVXlj
      RVV5UW1FMmNYbGxkRnBXWkFwRlZqWnVTM0YwZFhCd01GZEVSVkJHUWk5UVpqVnpabnBEUmpoQ2Vp
      dHZSRTVFTVRWSGRGSktMMlZNVTI5eFFrTmpkeXR2TTJGUlVVMUxOeTlNV1RsWUNuSm5iVlJTUWpO
      c01FMDRObFl3V0hFeFUyWnVjVXMxZDA1dFQyZElha3hLZW1SaWFsRnRUME0zZDIxRGRFNVJSMDk1
      YkVNek9FcG1WVmhqTmtWbk1tY0tia0pHZWtvMVVuUnJUbWgwV1dWSFRFWTRUa3RDUml0VU9WRktV
      MVZaYXl0cVNsRXhSR3g0WkZGS2JVeENURnBsSzFGclRVcFhVM2hsTlVGTGIwdEZWd29yVmtWb1Iy
      czNaek5wT0QwS1BYSlBka29LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80821-2
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-2(1)
    - NIST-800-53-IA-2(11)
    - NIST-800-53-IA-2(2)
    - NIST-800-53-IA-2(3)
    - NIST-800-53-IA-2(4)
    - NIST-800-53-IA-2(6)
    - NIST-800-53-IA-2(7)
    - PCI-DSS-Req-8.3
    - configure_strategy
    - force_opensc_card_drivers
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
  tasks:

    - name: Check existence of opensc conf
      stat:
        path: /etc/opensc-{{ ansible_architecture }}.conf
      register: opensc_conf_fcd
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Force smartcard driver block
      block:

        - name: Check if force_card_driver is defined
          command: /usr/bin/opensc-tool -G app:default:force_card_driver
          changed_when: false
          register: force_card_driver

        - name: Force opensc To Use Defined Smart Card Driver
          command: |
            /usr/bin/opensc-tool -S app:default:force_card_driver:{{ var_smartcard_drivers }}
          when:
            - force_card_driver.stdout != var_smartcard_drivers
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - opensc_conf_fcd.stat.exists


# Enable Auditing for Processes Which Start Prior to the Audit Daemon
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_grub2_audit_argument,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = true
# strategy = restrict
# complexity = medium
# disruption = low
- name: Enable Auditing for Processes Which Start Prior to the Audit Daemon
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80825-3
    - CJIS-5.4.1.1
    - DISA-STIG-RHEL-08-030601
    - NIST-800-171-3.3.1
    - NIST-800-53-AC-17(1)
    - NIST-800-53-AU-10
    - NIST-800-53-AU-14(1)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IR-5(1)
    - PCI-DSS-Req-10.3
    - grub2_audit_argument
    - low_disruption
    - medium_complexity
    - medium_severity
    - reboot_required
    - restrict_strategy
  handlers:
    - name: insights_reboot_handler
      set_fact:
        insights_needs_reboot: true
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVE0ZG5jMU9FUXJhalZ3VGtGUmFIbE9VUzh2WldaWWNI
      cDJObU5KWkdSME9EQlJhM2xYSzFOM1pqSnhjME5wUVV3M01EUUtLMFpyY0V0UVlqUlBVR2hMZG10
      QllUTmpaMnhGU0haaVVFSmhVa0U0Vm1sb1ZYaGFMMFJTSzNaV1ZteE1kVWMwV2poRE5tcFdWWFZH
      Ylc5WVVYWllZUXAyWVVFNGFEY3dRMFYyYVRWelIyUTFRMkZyZWs5WGVEQldSVlpSWmxNME1GQjFS
      WEExZWpoRGVXaE9Mek5tTlRWbWIzVXpMMjF1YldzelZVTlZkRzR3Q213eGMwYzFjVkJDVFU4cmRV
      dElWVTFqYTB3d1NVSmpkV1p1Y1VaUFFsbHNSbGxJWVVKU09VUk1SMHh1VVRWeWF6WTRTa2d6ZDJs
      UVEzSXZjR2xDVFRZS1VHNWtWMnBDY0hkQ1QzUlhhbGhaZFRaclVHVklRbGx3T1ZGeWQxZDNiazEz
      TlRSTlRFNW1kRk4zT1ZsQ2JqRXJiR3g2ZUVSeE4zWXpXbVpvUjBwclFncFFhRzl0YUZSVGJtdGFl
      VEJRWW5OMkt6SmpLemx0YVZwcGRrSXZWbmRJZVVJd1RUUnFZMkZNV2tncmVFcGtNbFZCV0hSSGNV
      NDJZMXB1VjJ0Q1FYSllDaXRVUWxwSWFHUXJaV05XVmxSU2JrWjFjVUpTVmxkSFQwOVJVMGRhVGxB
      clFWbEZOemQ0WkdwblZHRk9Oakp3TVRGSFJFOURkR2RDZEdOeFMyMVBUVFlLTURWSGRsSTRjR2hs
      WVZWc1UyZGxXVmRPVlZWWGQzVkJiMXBKUm5NcmR6UkVka3c0U0RWUFUyOTBNbnB6TkVkYWJVTXll
      RTg1V1V4eGRDOTJOSGQzWWdwMFJGaHZWRWx6Vkdsb1FraHhiM2xYVlhONFFYa3dhbGsxUTJVemIw
      OVdTeXQwWm5KMFVHUjFMMlE0VFU1U1RGUlVUVlpCV1N0SVRqUmlkM0I1UVZkdENuZHJNMWN2THpk
      bVJYSllXakZHY0c0eGNVazNZa3MwTUZwTlVHVm5iemRFTW13MVRXWklTRzF1TjFvd04wRk1NelV6
      U0Zweldrd3lUMjlMTWpCclMwa0tlR3R1VlZkMmNUWnFjbkJIT1RWNFdrUllUa280ZUZkaFZGWmFk
      VXRrUlRCWk5FZG9aekpqWkV3eFZWVkhiRXB5V1hNNVpYb3JiVkZNWkU1SldIVlpLd3BFUnpKdlRr
      NXlObU42TUQwS1BWRnViWGNLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Gather the package facts
      package_facts:
        manager: auto

    - name: get current kernel parameters
      command: /usr/bin/grub2-editenv - list
      register: kernelopts
      changed_when: false
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"grub2-common" in ansible_facts.packages'

    - name: Update the bootloader menu
      command: /usr/bin/grub2-editenv - set "{{ item }} audit=1"
      with_items: '{{ kernelopts.stdout_lines | select(''match'', ''^kernelopts.*'') | list }}'
      when:
        - ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]
        - '"grub2-common" in ansible_facts.packages'
        - kernelopts.stdout_lines is defined
        - kernelopts.stdout_lines | length > 0
        - kernelopts.stdout | regex_search('^kernelopts=(?:.*\s)?audit=1(?:\s.*)?$', multiline=True) is none


# Prevent Login to Accounts With Empty Password
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_no_empty_passwords,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = false
# strategy = configure
# complexity = low
# disruption = medium
- name: Prevent Login to Accounts With Empty Password
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80841-0
    - CJIS-5.5.2
    - DISA-STIG-RHEL-08-020331
    - NIST-800-171-3.1.1
    - NIST-800-171-3.1.5
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-5(1)(a)
    - NIST-800-53-IA-5(c)
    - PCI-DSS-Req-8.2.3
    - configure_strategy
    - high_severity
    - low_complexity
    - medium_disruption
    - no_empty_passwords
    - no_reboot_needed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVE0ZG5jMU9FUXJhalZ3VGtGUmFpOXFVa0ZCYVVsUWRE
      QkpUVWhTWjBVMmNVaDZNQzlMVjJVM2FFcEhURFl3YVZwRmQwRUthRzE2UlVKdGRYZzViRzlKUkcx
      Tk0yNVhZblZEWTB4RE9HbGxhMkp0VTNwMFkzSnZlRE16ZUhnMlRWZzFjMWx4ZDNGQ2NIZFdVRlZT
      VkhVcksyWlFlZ3BCUkVOV1ZuaFJlRGg1Y2pKNVlTdDNVMmRZVWs5dFMzaEtTek5vYld4a1dFWlFa
      R293VFZsMEsxRk9jRUUyUlVsVE4wUnJRMUpGY1dkdVlWSnhNREJwQ2tVNFpERTJVbkIyZEVaa2JI
      UjVPRXhDVGxaQ1ZWUnFRVlExYzAxVlpFbFdkMWtyYTA0Mlp6UlhXRTl2WkhKelpVUTRXa2cxWTIx
      clJtbGlaRTVsV2xZS2NsWXpZemwxVEZCbFRYTXpURkVyWTB0cFVXMVpZVkZyY1U4eFVrTXhkRXd4
      UjJkR05VVjVUaTk0Vm10bVJWVlBWbFF6ZGxrM1ZsZDZVVE0zWkdvdk5RcFhUVWxFUzJwNk9GVldR
      alJzWkhKUmFVUlljV3RFYVdkdFZrVm9TVFp0TlhZMGVEWlBPRTR4SzB4aWQwWlhjV053U0VKRGNt
      MWlkRFExUWpacVlYcENDbUZ1VEdWU1psRlpkMWh6UzJZcmNHazFiVFZRT0dST1prNVRUWEpCYTNs
      SE4zVk5aVGx6VFZSTk5WUldTblUxUjBkYWFIWnFWbmdyVW14WFRXNURibWdLU1c5VlFqQlBiR2R1
      VkZoS1FsUnNZblJJZUdWV01IQldTMHh3ZVdnNE9ISnBjSGhqZG01bWNHUnNjVTVOVjFoNk5rUllT
      a2hUTDFWeVdVZzFRVU15ZUFwTldESnNhMlZuVTI1QmVEUjBLM2RXY0hWbVNXd3ZXbGhuTjNWbllr
      TkhkMmRrVDNkeE4xRlRSM1V6V1d0bWIzZDNPWHBZU1cxVGNUWXpaMmR4VjNkbUNtZDRURWxGTURN
      eWVIUnBTWGRJWkZkTVVWUnRTMEZPZFhsMVNuRkhUVGRCS3poeFNGSnRVVFJTUVROcE5XaHpNRTFM
      VURkUVlYbFlUVVF2U0dkUVRVVUthSGxuVDJSQ2FEQTRaa0ZMYVc5a0wyODFTMnRqTkdGT1UyOVBW
      VWg1TldsaE1XMUtZWEZqUlZsSlJEQllSRkJXUzNZeWVqRXdVSFZtY2pSbk9HUjFaQXBpT0dwbVJu
      ZzFPRWhpY3owS1BXWm1kVFFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Prevent Log In to Accounts With Empty Password - system-auth
      replace:
        dest: /etc/pam.d/system-auth
        regexp: nullok
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]

    - name: Prevent Log In to Accounts With Empty Password - password-auth
      replace:
        dest: /etc/pam.d/password-auth
        regexp: nullok
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Install AIDE
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_package_aide_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install AIDE
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80844-4
    - CJIS-5.10.1.3
    - DISA-STIG-RHEL-08-010360
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-11.5
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_aide_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVZOZG5jMU9FUXJhalZ3VGtGUmFFZFdaeTh2WXpCTVdG
      aHJabkZEZW1vMVdXd3ZPVzB6UTFScVYyRk1hVWxDYUVKaWFIa0tMM3BxVFd0R1YxQTNkRmt5WjNO
      YUswOHphRFJyTDB4M1RUVmhkSEJvWmpSUFpUVldOMFJuUVhRNWNHWkVhamROY21SR01FeFllRk5R
      TDBkV1F6aEJVd280V0RVeVpGZHNNbTh6UVU5NWVTOVpjMHg0VmxwVmRrRkRkRzVhU1ZCRGJHaDJX
      bU4zVFRGS1lVdHBkR2Q0Ums1R2NUVTRURWd4ZFVKU1VFUlZWRkptQ2tKaVMwcEVMMFkxYm5jclVu
      a3dNa3RIY1ROQk5WQjNVMW96WlZwU2VIWXJja1JUZDFGNU16VlFLMmd4ZUVOcFlrOHJZMlV4Wkhk
      VEt6bEhWelp6Vm5ZS09FRnpMMDQzU1hKd1prUlNhQzlqZVhGVmFsVnhMekoxYkZjeEx6bGphVU14
      UW5GQmJWWTNaMnh2Y1hoSlVHRnRjUzltYmxnNFRqaEZkRVp3SzNOV2FRcDZkMmhRWWxkRVZVTnpV
      MnRUYVROYU9FWjRWekIxYTNkQ1NVNDNNUzluVkVkemVtd3ZjSGM1Wm1Wa1ZDOTNURFZwYzFaTFFW
      VnRabkYxUkZCMVZHbHNDakpDU3pOWlMycEpMeTlZT0dZeU5VSnJTRE53ZFd0R1RUVnhMMmhNSzFG
      NmFHOW1VMHBIWXpOcVdYTXZRMG96UVZnM0szcFFWMHRSWlhod2EybEtVMVVLVERRNE9GbEVha0V2
      Wmt0a2VFWllUVFl5WWpSNVpIVTRlV3BtYVV4WmFHWnVWWEZSVXpaeGNtTjRhbFkwUTNodVJXNTFX
      VVZGVFZsWldUaERLMmhPY2dwNlFtbFlLeTlzVlRsdFNtZE1UWGw0WXpnd0swSmpaVGxQYURZdlZt
      NTNTSEJxTVhVeVZrc3dSbWx1YkVOUGRIQkZWRTkxUVdaVFNVOVlaMFkwUTNaSkNrVXJZMmxFVm01
      MVVuQTJkRXRyVW5oTlNVRnRjRWw0Um0xemJuWnZibTl2VVc5MlQxUlVRbEZGZWpNMGQxSk1URmsy
      T0ZaeGRVZFFNalZvVURsb1JVRUtXak5LVlZCTU0yTjJWMHQzT1ZFNVdUSkRhVVJWZUhWdk9XeFlO
      RmNyWW5OSmJITTBVRUo0VEV4Q1RsVlJOMlZzU0VSRFpuUjJSV2xTZDFkWmNYVXZiUW8yYms1b2RV
      VjVkMFl6TUQwS1BXRmhWakFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Ensure aide is installed
      package:
        name: aide
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Install audispd-plugins Package
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_package_audispd-plugins_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install audispd-plugins Package
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-82953-1
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_audispd-plugins_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVZOZG5jMU9FUXJhalZ3VGtGUmFrSkVRUzg1UmtoQlIy
      RTJWVkZtVUZaNmVHWkRVbkZqTkhFeWFXTnlTRGhCYmxweFVFOEtVekpNU0cxWFUwZFlRbE5XWW1v
      eWRUWmxSRFJCTDFKVGMyWlJWRFZ2TjJReE9XSjZiR2hDVVRFM1RtMWxTMVYxUXpGeldETnlUMlZy
      WXpWMFZrNVNjZ3B6VWpVclRTdHlTV1JvT0ROUmExTTBNRmMwWm1GU1JsaDRRbXh2VnpKRlFuTlRk
      SGszVTNGamVWaG5WRWhzVmpoaVdFdFlkMnM1YVRSU2VVdG9PSFJUQ2pONFZISldkMjFCU0VGelYw
      NWtTRUpHTTJOc2VtcDVOUzlUZW5kd01rWjRSa1p1U2s5RWMydHlURE5PUTFSalpFbENMMVpEVkhZ
      eWNUQlhaMU5SY0VVS2RDOTRlVlpvT0RWbE1uVlRWRWRCYzJ0WGVITjNZVXRuTVVGaGNVUTJWSGxo
      VXpOaU1sZzRRbWQxTm1GSGVrMXZiRVJVVUdKRWJ6VlRWamhxY25ob013cEdRVzFCTHpaMU5FNXlW
      bVo2UjB4TlRWbFNaVUp4THpSeWNEaGlRVlpCVVZCaEsxQmxUbWxRUkZjd1NtUnNNWHBwVlVaV00z
      QTJkVWt3U2t4TUx5OXRDblE0ZFRoU1JIVnJZbkl2Ynk4M2RtdEhZV0pqUVd4NFpEUjFMMDlWYUV4
      TVFUbEZaa0kyYm5FdlJqUm5Va1l5U2pkWU4yRlhPV3BuTW5CbVNHMUdLeklLUVRodlVYTk1UbkZE
      ZWxjNFdGSlJVVWhqVkRGWVZreGhWV1kzYW1oMWF6aEZXVk5yUldWc01FeHlaMFZ6ZDBWMFdIVnZZ
      WGMzU3psRVJrZHVjVWQxV1FwS01FVnJhV1EwZEc1TWVrWmxlSFp4VERGR1RrWndTRFpJUVVvM2FH
      RllhamhxZVZFM2MyOTFXVFZUZFdSbmVGaDZSR2xhZFd3Mk9UVXZkSEZSZEdwU0NtMDRhVTFMVmtK
      S1JHdFZjbXRQTTFOWk5GUkJRVEZpUmxobE1HTXZlVEJ1TDJ4NlZGZ3hla2RyUVRSS1NqSkRNV1ow
      TVdZMFQwaG5WbFV3ZGt4RGVEa0taVFYwYlVWM1JGWTRaV3Q0Umt4WFlpODBOQ3N3Um1GMmQwaFdO
      RlEzU1VKWlIxVkhRM0ZZSzJndlRqTkpibEZDSzJGclEwcEdUM2hRYVc1dk15c3JjZ296VVhjMFdu
      RklVMlpaZHowS1BYSlJkellLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Ensure audispd-plugins is installed
      package:
        name: audispd-plugins
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Install libreswan Package
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_package_libreswan_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install libreswan Package
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80845-1
    - NIST-800-53-CM-6(a)
    - PCI-DSS-Req-4.1
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_libreswan_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVZOZG5jMU9FUXJhalZ3VGtGUloyMU1hRUZCYmpKbk9I
      bFlhR3BwY1hsU1kxRXlhbWxrZVVKd1ZHSm5OMHRVT1ZCbE5UY0tjMG96ZDFkWlNFaGtjM1JQWkZG
      WVZFMXpXakJ4Um5aVU0yZFZSSEpDTnpsU05WWXZXR0UyVEc1SWRtdEpiMEpQUVROaGRWRnlXRFZT
      T1d0RFVreEpUZ3AwUWxGaGFHWjRORmsyZDBkS1ExZ3pTazFNUkVSQlJDODJMM05HWnpoTmNsUTFS
      Mk5VTW5kTk56Wm5Ubm93VTFGaE1HRktaVWh5Y0c5dFEwMDVTbUpJQ21NdmJHczBSSGhqUjNWclMy
      ZzVORzlYU25FeFkzcHFTelZNZVhkT0wwVkVXbUlyYm5GeVF5czFNWGt2WWxCWlluQkxiakp4V0do
      eFIxUklZalYzTUdNS05VTjRiV2M1T0RJdmMySnhabEpOZW5KWFMxTmxPWEpRVWk4eWRscEpNREpG
      TDFwblNtOXlhR1pKVDBwNFNGRkxaMDVzTjNSR1FtOU5iakkxY1RSaFNncFpSMEpMTnpaeVdqRnFR
      bWgwYUZaSFNDdHhkSEJKVGtWcFVsWXJSa2hLTjFKWmVWSlhSVlJLUVZsTFVHTXhOM2RxWWxseWJq
      a3JaVTR5UlM5UVF6WlpDbkJQY0hOMVpWTkJhRzVuZDA5RlZYUXlaR0YyVkV0NU1EY3ZMM0ZXTm1K
      aFkySm9WVFZFUkdaM1lUTm1lbFY0T1ZSQ1FXbFROM0JTVW5SeVptaE5jV1VLYmtNMFRFODFMMFpC
      T1hWMlVWZFVWMlpOWTJwNWMweDFUWEIzYjBwTllWaDZRekJ6Y2tjNEwwSmhZWFJzT0ZsaldrczRN
      VzVpY1ZSa1ZWRk1hbkUyZHdwQk1raFRWVzRyU0d0R1UwSmtaM2RDZEhGWlNVRnRlakowYXk5WFNs
      TTFaa013Y0ZnMlQzbFFUekZZVFdoaFUzQklVM2hhU1hSd1lVUnZZa2hYYmpjdkNtVXpWWFoxVmxC
      aFVua3JPRWM0T0d4SWJUVlFWaXNyT1hOM1VrZE9RVnBIZEhSRmFVRkhVall4UzFaV2JtSnVRaXRU
      VkZObk9XcHpXSGhHZW1WNmJqY0tORUpoYjBWV1FVOVVNSGw0WmxsRVRURjFTMHhxVkZSbFJHUlhV
      MEZCYzFkR1IycDNjRVJ6UWxadVVXZHZhR0ZNYTA5Tk1XZzVPRzVVVVRoYVRFOWpSUXBFYVNzellq
      VjZXUzlITUQwS1BWazNiRUlLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Ensure libreswan is installed
      package:
        name: libreswan
        state: present


# Install the opensc Package For Multifactor Authentication
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_package_opensc_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install the opensc Package For Multifactor Authentication
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80846-9
    - DISA-STIG-RHEL-08-010410
    - NIST-800-53-CM-6(a)
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_opensc_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVZqZG5jMU9FUXJhalZ3VGtGUlozWjNRa0ZCYmpoamQw
      c3lNbUpDVVdseFdVc3lSRXQyV0VWcFIyUm5SMDlHY2xGdlVXOEthbkJYUjB0MmNrVnFZV1VyY25F
      MU9IVndablo1TDJaSFRXMTRTbk5yVG1JM2QzRk5RMlZNVEV4TmVraDZkek4yTTNCU1pGQjVXVVJt
      VWxreE0wSjJZUXBzY21kSFdTdDNkQzl4UVVFcmNXcDJZVXRDZFdSblUxRnJNa2w1TUU5TU1FVlVT
      RVJJVUZkR1p6bHZTbTkyU1ZwdEwwWTVaRUV6WkhwTlUxTkNUV2hzQ2xab1RpdEdVM2hxT1RoNEwy
      dHRhbmR0YWxCd1JtRk9URU5oTVhnNVJrZGxjVzE2WjNKS09YQjBXbFJhUVZodlMwaHRjWFJ0UkZS
      RU1pOVZka2M0YWtvS1ZucEZOMGszVFZKMldsSTBjMFZSUlU5RE9UZHlhVXMzUmpWWlRHeElXRVpU
      UnpSMlNuSjJkbXhvUVdaSGQwNDFjVTl2V2l0VlRtVTFjbGwzTm1ScVdBcHJjRzB5YUZwTVJsbENU
      WGxhTTA1QlRGQjVWMFV2YmpKaGNWcHVlbVZ2TTBzdmRHSllTakJaY2tkTk1rVkNVakZ1V1RGUlpX
      Rmxha2szTjI1blNFbHJDbmR2UzJvMVEwWkVjMVp3VFdzelpsSm1PVWRPUnpWdWEwTkZkMXBhU0dw
      UVZYZEdjbTFuVDJoRVVYRnFNVmRVVW5NMFozWk1VV1ZHTDI4eUsxSndNR01LY1dsRk1UUnhiakZO
      V1RsRFlUWkRjMk54TTB0VFpsUldTbU50Y0c5MVdXcFBhMlZGZEdKQk5IRXlVMFZxVm5VMk9Ib3li
      MEZDVkZncmRYbFBhME0xVHdwWE1rRlhNRGRNTjJvM09VdEhOMmMxVEdzelExUlFSVWh4VEVwVE0x
      ZHRhVXN5Vmk5MmQyWjNLMVl6ZW01S01reDViRTB3Y0hnMFYxbEdjekp6WTBwTkNqTlVPVkIwS3pB
      MlpuWmpPVGx5Vkd0NmJYcHJkbmRwZVdscFFVaExPWFZJV0dabmFreGlTbmd6U1VObGFsRk9Telps
      VURKWU1FaE1aMDB5Wm5CdVNIb0tNbWRhTTFkVFZrSnBPRVZ5ZUdsMFVGRXdVbXhrWW1KSVlWUjBT
      R0ptWTJOdksxVmFjMjVxY1ZaMFZuRk9aek00UzI5MFdFOWllWGx6VGpoTU5FRXZVUXB1WTFnNWIx
      bE9iQzlGYXowS1BTOXRWR1lLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Ensure opensc is installed
      package:
        name: opensc
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Install the pcsc-lite package
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_package_pcsc-lite_installed,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Install the pcsc-lite package
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80993-9
    - NIST-800-53-CM-6(a)
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - package_pcsc-lite_installed
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVZqZG5jMU9FUXJhalZ3VGtGUlowRlpVUzh2VVcwMFFX
      TmhNelUwWldobldtbEtZazh2VVdSQ1ltbGtWazV5T0dKeU0wNEtOV1F5TVdsMFMwbHRXazQxWml0
      NGQwSkRWRTFNZFN0WFNrUkZPRWxUUVdSVldHWjFjMk5sYldkRGVFaGhORFJrYjIxTVRXbHpVemhv
      ZUVaaFRIQlNWd3A1UVRZd2EzUk9WbW8yY1hWVWNUWnpaV0pGVEdFMVMwWk9iM1ZLTlRsMVFYTTRW
      bFZwTjBoU2VHTTJWMjVKY0VkT1QxVnlkWFZ4WkM5alZ6SjBXWE41Q2tKVFVrUm1lVUYwUlhOT1dE
      bFZUV3RGWVZKaE5rdGhURFpNZUZwQk5UaEJNMjh5Y0hJMk5YRkJiR1Y2WTJGeE5IQnhXVnB2TVd0
      a1kzTlVPRzVZWTBzS1kxQnViV1F3WlVkSU5VVk9TRmRHYTJFMU0zSktOVFIyZGxJNFdXdHZWbHB4
      ZW5kM2JHaFViRlpOUTFCM1VWaGFOazl4TlZwbVlVdEdWbUpOU1V0WlRncHVlRmhvVnpkblVXbEZN
      R2RWVFZRM2RHdEtTak0yY2l0MVRXTkdWSHBVYXpkTWFsbEpRa0ZLTURjMVVsY3hUWE5OY1hOM05G
      QlVVemcwZEU5U2NGSmhDaXRpTW14eFFtc3hVMGhZZFhsSlluUkZSRzVHZUc1YWFUQTROVmNyVEZN
      M1lrVTVkRk0zWTNCSmJYcHVhRU12VVc1Sldta3JkVXRIZEdRd0t6QndTRThLVnpoaVpHOHhVemt4
      ZFRNM1JrWnllR2RwV0dJNE1UTnBZbUptUzJoU1kwOW5jMngzT0dKT2JVSlFRMWx5ZVcxUGVrcGhN
      bkpWVEVKR1RXOHlOMFkyU1Fwc1EyVkhWVzlUVFUxR1lYWkVZV1ZSWlUxVWNWZGlZakJwTUZwMU1t
      NWxiblphUzJOeFVtbFVhRWcxWTNjcll6UjRRMHhMU1ZWRlRXazRkWGhNV1hKekNtOUlaVEpvTlZo
      WWRESlBibVpZU1V4VVlqRXpiMUV5VmpCS1QxVjJlblkyYjJoalZFeGhSMDVQZDNSNVRGRlBhR2hY
      VmpKYVZXSmpUV1ZoT0ZSSFNqa0tUVWRzVUdsdFUzbDVlWE41UmpKVmNWSkpLMWxEVTJoVWFGbzNN
      amd3ZVdJNE9IZzJhelIwTTJaTVZHMXllRUpWTUdGdGFHaHFlamx0ZURkNFVHVlBTZ295T1dkSVlY
      QkNTbUV2UlQwS1BWbFJkWFFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Ensure pcsc-lite is installed
      package:
        name: pcsc-lite
        state: present
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Verify File Hashes with RPM
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_rpm_verify_hashes,fix)
# Version: undefined
# platform = Red Hat Enterprise Linux 7,Red Hat Enterprise Linux 8,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = false
# strategy = restrict
# complexity = high
# disruption = medium
- name: Verify File Hashes with RPM
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80857-6
    - CJIS-5.10.4.1
    - NIST-800-171-3.3.8
    - NIST-800-171-3.4.1
    - NIST-800-53-AU-9(3)
    - NIST-800-53-CM-6(c)
    - NIST-800-53-CM-6(d)
    - NIST-800-53-SI-7
    - NIST-800-53-SI-7(1)
    - NIST-800-53-SI-7(6)
    - PCI-DSS-Req-11.5
    - high_complexity
    - high_severity
    - medium_disruption
    - no_reboot_needed
    - restrict_strategy
    - rpm_verify_hashes
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVZ6ZG5jMU9FUXJhalZ3VGtGUmFWZG5aeThyUzBOcFRX
      NTNNMHQzZUhOWVZHdGtOa2cwVlZsRVZreERTelZRTVVsWlNWb0tkbXh5WjBRNFkzcHJLMUp4U1dF
      eFFuZHViRlYxYUZGclJDdEdPRFZWVVZaaFNtWnhhRmhOU0dWSlJrUllhVTB5Y2xWb1dtMXhaR1Jp
      VDBKQmVqRk1hQXBCWW1SMlpFcDRWMHhGYkhwd1prcFhSVko1VTBjcll6ZEJWamR2ZERNM1ZYcFhl
      a0ZPYlZaUlMzSkxTSGRDZFdjcllYQTJVMVZMWlhjMGFUTjVUMk54Q2t3NFFsTXZVR2xDT0VkSk1X
      UnllRzVSV0dsbGEyaHBNSGhhVUZobFUwaDBVazh3YjBGWldFNVVSbEJpZUN0T1JHOVpVMXAxUlVs
      UWNHNUJjblptZGtjS2JHVnhVbXBVU1hSaWJHZHdSVmxhVDFOeFNqY3JRbkIxVTFoamFqRlRaVlkz
      U1ZvNFQzQjFNM1pQVkRBNEwxcDBPRk55T1dVeVZHZEZiMWhCTms5cFpBcG1la0oxVmtnMmEwcDFk
      RVJrVkdFMFJsSnpWV1ZHZUd0dE5IUndTVTlKZFZCYVVtcFZZMVpRU1dseFJFWlJLMmRoVmxSSmFV
      WjBXbFExWW5kU1drSmtDa2hxV1ZwWWNtWkJNWE5FVG0xVWRXOWtja1ZuUVN0U1RFbHplRmRIV2s1
      RGJWTk9NM0ZHTW5KaGNGUlhlWE0wTURsellqRTRTMWhGVld0T2IxSm5MMndLZWt3eGRtWnhaWE5u
      VDA4ME4wZGtNak54YlM4M04yMVlNRGxLYzJwNk1HZEhkVlZLWTJ0NWRXWXljM2h4TUVSNGNscFVO
      bTgzYm5kNVZGSlFTVXBMWmdvNFJYSklLMjFEWjNsclJ6UXZVV2xHVkZGbGNVMXZTR0pIVkRSSkt5
      dEZkRkkyU2tKak5FMUdlamhDUTNJeGFHeFlZVWczTld4SVkySkphakJxVVhCcENteGphalJQTkU4
      M1ZYbGlTMFo1YlVWVE1FdEpabWx6U0ZGUlFUbEpWVTRyZFZJeldXcDFNMDlVTDNGcVR6SkZUREo0
      VEdKVloxZzRaa0pDYWxNMmExa0tOVlJMUml0dmRtUjRla2xOUW1nMFVXNVBabVJsVGxwcU1GWkNU
      VVpZZGt4V2VXMVBiQzlFV2tGc1NtdERlVE51WjNFNGVUZzFZVnB6UldKak1FZE5WQXBCVDFoalkx
      YzJja1owTkQwS1BXSjNUbm9LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: 'Set fact: Package manager reinstall command (dnf)'
      set_fact:
        package_manager_reinstall_cmd: dnf reinstall -y
      when: ansible_distribution == "Fedora"

    - name: 'Set fact: Package manager reinstall command (yum)'
      set_fact:
        package_manager_reinstall_cmd: yum reinstall -y
      when: (ansible_distribution == "RedHat" or ansible_distribution == "OracleLinux")

    - name: Read files with incorrect hash
      command: rpm -Va --nodeps --nosize --nomtime --nordev --nocaps --nolinkto --nouser --nogroup --nomode --noghost --noconfig
      args:
        warn: false
      register: files_with_incorrect_hash
      changed_when: false
      failed_when: files_with_incorrect_hash.rc > 1
      check_mode: false
      when: (package_manager_reinstall_cmd is defined)

    - name: Create list of packages
      command: rpm -qf "{{ item }}"
      args:
        warn: false
      with_items: '{{ files_with_incorrect_hash.stdout_lines | map(''regex_findall'', ''^[.]+[5]+.* (\/.*)'', ''\1'') | map(''join'') | select(''match'', ''(\/.*)'') | list | unique }}'
      register: list_of_packages
      changed_when: false
      check_mode: false
      when:
        - files_with_incorrect_hash.stdout_lines is defined
        - (files_with_incorrect_hash.stdout_lines | length > 0)

    - name: Reinstall packages of files with incorrect hash
      command: '{{ package_manager_reinstall_cmd }} ''{{ item }}'''
      args:
        warn: false
      with_items: '{{ list_of_packages.results | map(attribute=''stdout_lines'') | list | unique }}'
      when:
        - files_with_incorrect_hash.stdout_lines is defined
        - (package_manager_reinstall_cmd is defined and (files_with_incorrect_hash.stdout_lines | length > 0))


# Verify and Correct File Permissions with RPM
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_rpm_verify_permissions,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv
# reboot = false
# strategy = restrict
# complexity = high
# disruption = medium
- name: Verify and Correct File Permissions with RPM
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80858-4
    - CJIS-5.10.4.1
    - NIST-800-171-3.3.8
    - NIST-800-171-3.4.1
    - NIST-800-53-AU-9(3)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-CM-6(c)
    - NIST-800-53-CM-6(d)
    - NIST-800-53-SI-7
    - NIST-800-53-SI-7(1)
    - NIST-800-53-SI-7(6)
    - PCI-DSS-Req-11.5
    - high_complexity
    - high_severity
    - medium_disruption
    - no_reboot_needed
    - restrict_strategy
    - rpm_verify_permissions
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVZ6ZG5jMU9FUXJhalZ3VGtGUmFYUTNkeTgzUWpCUmRI
      WlhSMVp1WW5Sa1RVeGtRMVZzWVRKcWRVeENjMmtyVW1kTUwxb0tTRk5OUkZGc0szWk9OMmhVVUVG
      VVNGbGhWbVpaYjFkSVdsaHdUR2hIYmpNcmNtTkVkVkZWUWxZelZIbG1ZVnBKYTJOaVNtdHZkSG81
      UkhScVp6RjRRUXBZZFhWUVNXdHBZM0JFVEVWMlJYWnViMHdyVTI5SVZrazRiR1o0UlVJd1lsbE5W
      RkptZVZOTFl6ZFlWak5HZFhGR1psQnpNbnBQWmt0MFkxWk9aMnREQ2poWGFrNXpXVlZ4WjA1RU0z
      QlhVazFqWjI5VGJHbENlWE5WY2t0clpTdHBkMHBhVFROTEwySXpjSEZ2V1RWeE1EUkVTblF6V1VW
      TGJsWTNhSGtyYkdFS1JHOTRRa05ZWTA0NGVHVnhZVW8zVVdwc05tRTNaRXBNV21sTWQyZG9lRzg0
      YmpOYWFGcG5hRk13UjJWUWJEVlJhSFEzVEdoQ1VubG5OVVpxVGlzdldncFNSWE54VUVGWlJrRnpa
      VlZWTkhweGQzaExiQzlFZVRkMlJWRXlWbXhhVjFoWGFtUkpNRmRPYmxCSGVsSmpTRXhhVTBaWlRr
      b3hTR2xuTkM5RE0wb3pDazVvWTBwRk5GTk9jRXBCT0Zka1NuSldjSFp2WTBocWIyRlRPRUZoYmtG
      M1RGUkRNMDU0S3l0S2MwMUxRWE5RVGpkdmFFNUpWbHBaWlUxMVZtMURaV1VLYm5CUFRHRjVhV3hZ
      Y21kM04zZEZjSEUyVjNkTldIUXZZblJHYVRCMVNXbE1RVXhPUVU1VGNVa3ZOSFZ4YUVaNlpFRkNi
      R1ppUVN0T2RXeG5TV2M0YXdwU2NIQnRiVWxRT1hwRVdHTk9aMUJaVWt0VFQxZ3lPUzg0T0RJMFRU
      ZzRibEpJWkhBNFZEZG5jbFJETHl0YVdtWlBjMFZRU1ZCNVZubG5TWGRuYzJvekNrUkNPR0ZaYTBk
      TEwxcDZLMnRCUzFWWFpDdHBkRmxRWmtWeGF6SlpRMWhUYWsxMk0xcHFLMjVqTVROSmEyeFpNa0p0
      WmxNcmFGZE5iemxsV1hsNU4za0tiblYzVGpCRlYxbzFVRGx1ZEdKVlJYaFZiVFpoYUc5UVZGaFNj
      bXRQTDAxTVNGVmlkREl5WTFsM09UUmlPRU5FUmxSWlNVbEJabTgxTDFwb1FrdDRkZ3A2Wm1aTmJH
      dFBLM1Z2VFQwS1BUaGxiRUVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Read list of files with incorrect permissions
      command: rpm -Va --nodeps --nosignature --nofiledigest --nosize --nomtime --nordev --nocaps --nolinkto --nouser --nogroup
      args:
        warn: false
      register: files_with_incorrect_permissions
      failed_when: files_with_incorrect_permissions.rc > 1
      changed_when: false
      check_mode: false

    - name: Create list of packages
      command: rpm -qf "{{ item }}"
      args:
        warn: false
      with_items: '{{ files_with_incorrect_permissions.stdout_lines | map(''regex_findall'', ''^[.]+[M]+.* (\/.*)'', ''\1'') | map(''join'') | select(''match'', ''(\/.*)'') | list | unique }}'
      register: list_of_packages
      changed_when: false
      check_mode: false
      when: (files_with_incorrect_permissions.stdout_lines | length > 0)

    - name: Correct file permissions with RPM
      command: rpm --setperms '{{ item }}'
      args:
        warn: false
      with_items: '{{ list_of_packages.results | map(attribute=''stdout_lines'') | list | unique }}'
      when: (files_with_incorrect_permissions.stdout_lines | length > 0)


# Enable the pcscd Service
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_service_pcscd_enabled,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = enable
# complexity = low
# disruption = low
- name: Enable the pcscd Service
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-80881-6
    - NIST-800-53-CM-6(a)
    - NIST-800-53-IA-2(1)
    - NIST-800-53-IA-2(11)
    - NIST-800-53-IA-2(2)
    - NIST-800-53-IA-2(3)
    - NIST-800-53-IA-2(4)
    - NIST-800-53-IA-2(6)
    - NIST-800-53-IA-2(7)
    - enable_strategy
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - service_pcscd_enabled
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVU0ZG5jMU9FUXJhalZ3VGtGUmFrZFlRUzh2Wm1GeGVu
      Vm1aMk0xSzJRNFYxVk1Ua1o1T1RoMU1HdFNkSGd6YkRSUVIyVUtSazFaZURWcVEwMXBSRWxDUjB0
      emFGUnFWMDlGZGxNMVlVNHdTM3BXZEM5UWFGTlFiVkUzVm5aVk1WaHZVRU54YTFCVVRqRTJTbkZZ
      VjJKclVYQlRkQW8xZUV4S0t6a3pabm8zY1hBd2RXeHdXRWd2UlZwaVNtcGhVemRJVUhBNVRFTnRL
      MlZYUkd0TVdWQlVjbVZSY20xMVIzUktiV3N6VGpKaVozbG1jRFJwQ201TEsyZDFlbW80U0ZaaFls
      QjVSblV5YVcxTk0zSlBZMjA0YW1ONFp6RlhZMHhCZGxWYVZVMVlUbEkxTVRGUFpESnNLMkZLWjNS
      bVkyNU5hMGwzZUdVS1NXazBWemtyTUZCblVrMXpNWHBrYUVOT1IwdGFOSFJXVm5selNtOVVUV2xq
      VVZvMlZtWmpkMlZFZDFOak16SnRWRTlDTVRZM1NuRXdNREJtYTBGcFpRcE1TbUZ4WTNWRWNGRlVa
      VXRQUmtsMWNVVmtVRXh6TTJKWVprTXlVekJXT1dKalVYQmxWRnByVVdWS2VVbGhURzVzUWl0RGRG
      Qk1lV0pVTXpsd1F6UlJDamRoVEUxdFRYRmFNbFZpZEN0ak9GUlpTRTg1TTFoTVNFaExSRlpoYTFw
      bVVHazJaMUpqVjA5NU9UazVaR0ZHVlhwb2NrUnhZbEZxTTFwV2VXeDRiMHNLVTJ0emVsbEtWWFV3
      YURkNE1HbDNVR2hQTkZCMU5GTXlaRmQxUTB0U1pWQk1TakF4YWpKSVVucHBMMHR5ZGxscWNIaE9S
      MjkxTmxJd1F6Um1MM1ZXUVFwWE16ZzRWa2Q2ZEVNeU1GQldRVmR3Y21sbVJuRnJaMjVLZEZOQ1VW
      Rm9PR1ZQUW0xSVoxQlpOMUpNUmtwRWJXbFBNQzlLYjNSS1RGSnhOamQyWWxaVENta3haa3BvVkZF
      eE1sYzFlVXRCVW0xWFNVOW1RVFpUZEhGRk0zTkVlbkJaWldaSWExQjBWa3B2T1d0bWJGbHFOek5X
      VlZscGJtMUtkeXRsTW5aeFlXMEtSRlpQYW1ocVoyVXdUQzl0V1Rrd1RFdGtTVkowYkZoeWRuSkRX
      SEF5T0dWaFQzaGhMekJQZDNrM2VrTkpRazk2Ukd0dVIyMDNOR2hFWjA1cFQxSXZWd3BsZVhvck9E
      VkllbE00V1QwS1BXRnFiRUVLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Enable service pcscd
      block:

        - name: Gather the package facts
          package_facts:
            manager: auto

        - name: Enable service pcscd
          service:
            name: pcscd
            enabled: 'yes'
            state: started
            masked: 'no'
          when:
            - '"pcsc-lite" in ansible_facts.packages'
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Set SSH Idle Timeout Interval
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_sshd_set_idle_timeout,fix)
# Version: undefined
# platform = multi_platform_rhel,multi_platform_fedora,multi_platform_ol,multi_platform_rhv,multi_platform_sle
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set SSH Idle Timeout Interval
  hosts: 'tower.lab'
  become: true
  vars:
    sshd_idle_timeout_value: '900'
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVpOZG5jMU9FUXJhalZ3VGtGUmFYUkZRUzh2VmtGc00w
      cHhWMGh5VjJKR1dqQklNVEo2TlZWbGEyOXZWa3g0TjBkUk5sTUtPR1ZyUVZkdU1IcDNOR2h4YkhW
      Q1dqSkpMMGRVTkZsTE1IRmxXU3NyZHpkUGJGZEVlV3huVUhSMFZtTldOVEJPU0ZreWFHTjBZVVpM
      YzA5NlluTlRSd3AxYUdacWNuSkpPRmxTUm1ZdldHOWxiMGNyZW1aTmIyeHlVM0kxWjBFeFdFdDBR
      M2hCUjJOaEwwRnBSMWQwZURSNlJpOHpiM0kyYnpWRlJrUm5iM1ZpQ25CemEyNW1VM0pGTUhneVoy
      ZHRUVUpVUkZsWGNWaG5TV3R6YlVnM1kxcG9PRTFCUVdWSksyUkxVMko1Y0RGU05GUTBibTV1UlU1
      Rk1HWkdUeTl2UTFnS2QxbERRVmhsVFVkblYzSnNkREp4ZW5KblpuWkljSEFyUXpRelVtaFJTMUZo
      U0hKVFNYQk9VblI2WVhWWmJqTm5WSHBFVmpSbWMwRnNVbFpwYUV4bk9BbzFjbVpqZEVzd1dsSk5i
      Mkp3ZGpKMlREUTRjWGR5V21OTlZYWXplREZwTDNGVlJuQmFjelpKUnpoeU1ubEZVVFpGZERZd1Fs
      WkNNVWwwYUdZNVNTOWxDa05DTDFVM1NGRmxWMG8yVFdVMmJ5OU9ZbEJ1TDBoT05IQndkMUpaT0Ux
      SWNtMUxjRTkzYTJsSVRWTmpNbVZ4ZWxaMGRFVnVNbWxTUWpCV2VtbE5SbWtLU0hoS1Jtc3pjMjlF
      Y21wMk1EZzFTMjVGVjAxSU1rOXVOMXBqYkROb04weFZhVmcwVGt0cWFGWnRLek0wY2t0NlpXWnBU
      MjlZZGtoUlpqVkNVMGdyYkFwdVVqWXpZakZDVGtSUVZFWnBSRWhKVFdKalpVRXhVV2R2YkhZNU9Y
      VnVPSEZKWlN0TVNHVkdRMGhRVldGaGN6aG9iM0ZJUkdkQ056Vk1WbXhoYldOSUNrWnBhbXBIWWxs
      MlltTlJWbEp5ZUZsT1ltTlpWVVZrT0ZNeGREbFBPWEV5TldWdVlWSnBRbkZ4ZUdSemMwOURLMjFs
      Y1dzMFVGVjRNVlp6VmxRNFdVVUtWVk00ZGxjd01EZzJOMkpuU0VWVlZWaEVSMXA2U21kSlIxQlBl
      RFJNUzNSd1l6ZEdTWEphWjNaVVYyUnpVRkE1ZW1GeFpsaHRVemhSYkdJeVV6ZzVRUXAwYUhnd1VH
      RmtSVXA2TUQwS1BXNWlZVllLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tags:
    - CCE-80906-1
    - CJIS-5.5.6
    - DISA-STIG-RHEL-08-010201
    - NIST-800-171-3.1.11
    - NIST-800-53-AC-12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-AC-2(5)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SC-10
    - PCI-DSS-Req-8.1.8
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_idle_timeout
  tasks:

    - name: Set SSH Idle Timeout Interval
      block:

        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveInterval\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveInterval\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1

        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*ClientAliveInterval\s+
            line: ClientAliveInterval {{ sshd_idle_timeout_value }}
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Set SSH Client Alive Count Max to zero
# Identifier: (ssg:rhel8|pci-dss|xccdf_org.ssgproject.content_rule_sshd_set_keepalive_0,fix)
# Version: undefined
# platform = multi_platform_all
# reboot = false
# strategy = restrict
# complexity = low
# disruption = low
- name: Set SSH Client Alive Count Max to zero
  hosts: 'tower.lab'
  become: true
  tags:
    - CCE-83405-1
    - CJIS-5.5.6
    - DISA-STIG-RHEL-08-010200
    - NIST-800-171-3.1.11
    - NIST-800-53-AC-12
    - NIST-800-53-AC-17(a)
    - NIST-800-53-AC-2(5)
    - NIST-800-53-CM-6(a)
    - NIST-800-53-SC-10
    - PCI-DSS-Req-8.1.8
    - low_complexity
    - low_disruption
    - medium_severity
    - no_reboot_needed
    - restrict_strategy
    - sshd_set_keepalive_0
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldWbExhRVpqZG5jMU9FUXJhalZ3VGtGUmFXbExVa0ZCYm1KSldW
      VklhSEY2V1dwdmVqUnFSMUF5V1RreWFWUkhiU3RIVDFCR1FWWUtNMVZTYlV0RVkxTnBVVVpvZFhG
      bmJHWk5TR1JoYXpsTmVHbGlTWGRZY2sxM2VYaEdWa2x4ZUVrd05tUkxhRWw1UjBoemExTkVUbU5N
      ZVZackwzRXpUUXBYYm01blUxaG9aWEk1VG5wTVJEVnBlR1JNWkV0VFFrOWpjSGh0YTFOS1pXMVFk
      VTVQS3k5S1oySlNNa1ZYVlhOeWJubDNVVXgzVEd4cGF6ZHJUREZUQ2pWTVkwdHlkVUp6UlZablR6
      ZzNLelo2TTBKQldqSkdNMWhyYzFaaGExWjFjVVZtYTNsbk1FbFBTVE14YjJ0c2VsQkVhWEpoVjJ0
      bFJsQkVjMXBoZFdrS1YzVjVORW8xWjBORmIydFJjalF4U1RKT1YyczJWbTVHVDBaMWRGVXlSek5S
      U1VsMGFsRktZWFZpY21GUWFIRjVZM1pOYkhKVGJuazRNMVJTTjBaNWF3cEdaM2hUV1RKdVpFcHFX
      bXN6TjFOT1pFZGFUbTFSYURoellYSnpWVkpxWkVGalZ6ZE1VR1V3YUZOMlRrUmFWblpUY1VOamVX
      aFVla2hhTlZJMmVsbEZDbm93WlRSdmQyRmlObE12VHpKVksySmxlVEJaVGxFMlIwVlpjMmxYTkV3
      dlJUbGFLMDlTVjNOT1pVNW9iQzlDTnpaWlNXRktOVkJ2ZFhSWlExY3pOV01LUms5c01rUnZkVzF3
      WjNkNmRYUXdWa0pZVUhsdlJsQkJWRmt2UmxGa2FXUTJZbVJRUjB4dFFrRlZSMmxoYTFkd1VHMW1Z
      a1J0YlZGYVduQk9Ra3BtWVFwbFRHd3ZWR0k0VmpCU2VuUXhUeTl5ZEdKTFZsWTRiVFpaVWxSU2Vu
      SjNTa3B1UVdSWk9FUk5iVUl6VVM5blozQnNXV2xWU2xScFozTXJiMmRKVEVockNubzNhM0ZLZW1K
      WldtMWpOVEppUms0MlpuWmtZVE5LVEhkS1drVkNZemhKYlhwMU5tc3paRVJtTjJjMFQxZDZUM2Q0
      Y2tGSVduTXhRbkJpY0ZselNtZ0tNVE01YzFBeGVVZENWblkzUVRablpGZ3ZXbkpITUdReVNpdHpX
      SE15ZFhoaVNFMXJNbkJOZDB0amIydHhhMk5vVERoM2VGYzBZMnhyZDBkTk5TdG9RZ3BuVWpaNmEy
      TkdOSEJwWnowS1BYTkJWalFLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:

    - name: Set SSH Client Alive Count Max to zero
      block:

        - name: Check for duplicate values
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveCountMax\s+
            state: absent
          check_mode: true
          changed_when: false
          register: dupes

        - name: Deduplicate values from /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: false
            regexp: (?i)^\s*ClientAliveCountMax\s+
            state: absent
          when: dupes.found is defined and dupes.found > 1

        - name: Insert correct line to /etc/ssh/sshd_config
          lineinfile:
            path: /etc/ssh/sshd_config
            create: true
            regexp: (?i)^\s*ClientAliveCountMax\s+
            line: ClientAliveCountMax 0
            state: present
            insertbefore: ^[#\s]*Match
            validate: /usr/sbin/sshd -t -f %s
      when: ansible_virtualization_type not in ["docker", "lxc", "openvz", "podman", "container"]


# Automatic system reboot was suppressed for this playbook.
# This play lists the systems that need to be rebooted manually for the changes to take effect.
- name: Reboot reminder
  hosts: "tower.lab"
  gather_facts: false
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldVaHBRekZ6ZG5jMU9FUXJhalZ3VGtGUmFHaDNkeTh2VVV4SFJE
      aFFNM1l3VlhKWmRFUldabGhaUWxWSFNGQkpUbkpNV1ZCNFFUUUtXWFJXUmtFd1ZXb3diWGhyVVVG
      RFNtbHNZbVJGYVVWdVJIaFVZMVpDZDFSMlpVd3dTVWR0Um5sVVZVWkRVVEZ6WkdRMVUwc3JRMlJy
      TjJKa2RHTmliQW81TlRkaWJtZzVXbk5xYm14dWEwOU5ObTlyVFhVNFNraDZSMDFRV1hST01VaHdR
      VGxJYVV4Mk9IaEdPSFYzTmtkMWQycE9PREJ5ZDNaMmVIZG1WWEpOQ2psWFdYZE1PVU51UzJaRk16
      QnVOM04wTDA1TGJFbDFMMmd3Y2pKU1JTc3hPV1Z0TUdodVJsQmhaa2RwT1RZeWRXaFVTRGhZYzB4
      VWVHOXlRekZhU0c4S09VeENlRU5PVWsxc1draGljVGhzYVd0UVJsaFBhekkxTlNzdmFXMUdkazlE
      V1hwT1RuRXpkVkYxTDB0SWFGTTVhemRaT0Vwb0wyRjZTRFYzYW5KNlV3cDNNekJ1Y25JeVNVOW1j
      V0V2VUdWRlJXOU5SbUV3UVV4WWRFZFVSREpyWmk5Q1pIVXlSemRUU0hkMFNsaG9VbEJzVnpKNU9H
      MW1Za2wwY0UxYWMyTlFDbFp2WkhoVmEwbGtkVXhUTmpaM04wODBPRTVRT1V0Uk9XbE9Wa2hCTVdo
      NVZTOTFWekkwT1ZFd2EwWjZlR3BEUVhsR1QwY3pabkZRUkhWaWNVeFlkbkFLTjB0bFJGWklRbFpS
      UVVkckwwUnhSMFpYT0hoMlVUUkZkSEpVTldrMlVsb3hVRlJMZEZCVmNrVmpRV2hoU2xsWlMwRm9X
      U3R4Y2pkUE1WSkhkazFxUlFwTlEzbFFjVlZ1U0hJMFNHSmtjelJTU0drNVJucFFaeXN2VjB0M2F6
      VnRhMUJMTUUxaEsyMUxkVXd5YTI1elUwaDFTakEzVkVVMk1HNU1WbGM0YTFwakNsSllibGxCU1ZB
      d1RGUnRUMHhvWms0NWJtdzVOM2hvUTNSUFdrZFBjMVp3WVhWdlIyZENOV0ZrV1ZGYVZXY3JSVzF0
      UldSQ1ZrdDZOVUp2VERWc1pYTUtVMjVQVkd3dmFEbG9hekpqYm0xVVdWRTFRa1JoY1RSdGR6QnFS
      SGhDTjFWUWNVdDFZazFDUTJoSVdIUnRVRFpGT1hSU1pYRnNiWHB0YWxkR2QxWnpZd3B1TDBGRFpW
      ZzFZVUUxY3owS1BXZHFZbWdLTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:
    - debug:
        msg: "Automatic system reboot was suppressed for this playbook. Reboot {{inventory_hostname}} manually for the changes to take effect."
      when:
        - insights_needs_reboot is defined
        - insights_needs_reboot

- name: run insights
  hosts: "tower.lab"
  become: true
  gather_facts: false
  vars:
    insights_signature_exclude: /hosts,/vars/insights_signature
    insights_signature: !!binary |
      TFMwdExTMUNSVWRKVGlCUVIxQWdVMGxIVGtGVVZWSkZMUzB0TFMwS1ZtVnljMmx2YmpvZ1IyNTFV
      RWNnZGpFS0NtbFJTVlpCZDFWQldVaHBRaXR6ZG5jMU9FUXJhalZ3VGtGUmFXdDRaeTh2WmtaRFoz
      QXlTblIxVEd0UU5qQnNTa3BZYm1GU1JGTjVjVVYwU0ZSNlRGY0tOVlZSVlc5MWEyUmpVRFJVUlZn
      d01EaDFhRkJHUzFaSmVrdFVTR2RsYTFOaU1UUXlkMjlQYm5sR2VUUnpRbEJrZEZoaGREVlliWEp0
      VGxsR1EwaEVWZ28xYVhSdlNrcDBPVzg1UWtkQlJVaDVZMFJ3SzBoNVNqWXphM0paZVRGUk1rOXVU
      azF3VjJaSmNtYzJUakJXVTJoa1JtVk1lR0ppTjBaMlpFaEpjbFo2Q2pJNGFrdHhOemx1Tm13eUx6
      aDZZVkJSTDFkWVZIWkNaMDVhUkVWTFJ6TmhSSFl3WVRkbWIyUnlPRWhEZGxseE5tNUhNRkZOY1RO
      U1ZFOXBkbFZtTTFnS1JuQnlhVTh2TDNKSlRDOVlSelE1TTA1NGFWSjBRakVyZEhSUk0wZHNhM1ZE
      ZFVwck1EQkdaREp0ZDNZNFprRnZaR2xUUW5aelQydEpZekZyV25adFN3cEJjR3BEY1ZKMWVHaExU
      MDgzYWxZM1FYSnRTV0p6TkhobVJrUkJVMkZaV2t4R01VMHZhME42ZWs1d1MwTjFhbE5hVUUxRlVt
      WlhhV2RHVGpGMWRqRjNDalpQSzB0b1pTdFJVRU5hUm5CV1kwVndSbTFSTVdwcWFrOVFPV2haSzNW
      alZWSnhSVEkyTlhGTWRuWnFSWE4wUW5WQk4xQkZNRVZ3UkRsaU5VaFZSM1lLTkZKemJXc3pNbFpC
      Vnl0WE5IWk1VRWQwZG1sQ00wSXpUbE0wZUhCdVIzSmlObGs1Y1cwNFZuVTJSRUZIV2xOYWRsbFlk
      bWQwTm1WR2N6RTVTVFZZUWdvMGVtcFVSRUlyTW1sT2NrcE9jM2d5YURoU1VGVnJMMmhZUzFKMGEy
      WnZZMlpKZVRkcGNWY3hiMGRsTlZSMmFqTTFSbXRqUld0YU9VRnpSMjl6WXpWMENuUlZkVlZJWWpS
      ME5EVTFSSE5EWlZWc1ZEZFNOakJDTTB4d1Z6TmlTRTF0YzFCMEx6RktNRFEwYm1KS2RFTkhUM1Jy
      UVVWWVRsVTJlbGxUTDNBMFFqSUtaSFYxY2tZdlNHUnFWWFJNVDNSdlNFTnlZVWd2WkZwaFRVNTZk
      MVZpZUc1VFZXUkdZU3R6TTBaNFJHczFVVkU0VVRaMVVucFpRbWw0WkcxeWREZGpUQXBKYTA1NlEy
      aHBRMDlrY3owS1BVMVZOMk1LTFMwdExTMUZUa1FnVUVkUUlGTkpSMDVCVkZWU1JTMHRMUzB0Q2c9
      PQ==
  tasks:
    - name: run insights
      command: insights-client
      changed_when: false
